title:  浏览器事件模型
date: 2016-01-27 16:13:11
categories: JavaScript

---

事件是 JavaScript 和 HTML 交互的基础，在 W3C 标准出来之前，各个浏览器都有自己的一套事件方法，有的使用事件捕获，有的使用事件冒泡，它们都支持直接在 HTML 元素上绑定事件，这个时候的事件模型被称为 0级DOM。W3C 标准统一之后，对浏览器的事件模型做了一定的前后兼容并新增了一些特性，这个时候的事件模型被称为 2级DOM（没有 1级DOM 是因为在 1级DOM 的标准里没有定义跟事件有关的内容）。
<!-- more -->
###事件捕获
简单来说，事件捕获就是假设父子元素都绑定了 click 事件，那么 click 事件触发的时候先在父元素出发，后在子元素触发。假设文档结构为 document-->div-->a，那么事件流触发的方向就是 document-->div-->a。古老的 netscape 浏览器用的就是这种事件模型。
###事件冒泡
事件冒泡和事件捕获正好相反，事件先在子元素触发，再在父元素触发，依旧假设文档结构为 document-->div-->a，事件流方向问 a-->div-->document。IE 浏览器使用的是这种事件模型。
###0级DOM
在 W3C 标准出来之前的浏览器事件模型被称为 0级DOM，一开始浏览器处理事件只有原始的事件模型，它把 js 代码作为 HTML 的事件属性值被插入 HTML 中比如 `<button id="btn" onclick="alert('click!')">click</button >`，或者传入一个函数名称 `<button id="btn" onclick="doSomething">click</button>`，还可以在 js 中通过获取对应 HTML 元素的对象给它绑定事件：
```javascript
var btn = document.getElementById('btn');
//绑定事件监听函数
btn.onclick = function() {
    //doSomething...
};
```
在 0级DOM 中，事件监听函数是作为元素的方法调用的，所以事件监听函数的 this 指向的是该元素本身，当在事件监听函数里面返回 false 值的话将会阻止该元素原本的默认事件触发，比如当在一个表单的提交按钮中绑定一个 return false 的函数，那么这个表单将不会被提交。另外在 0级DOM 中只能给元素绑定一个事件，如果绑定多个事件那么后面定义的事件将会覆盖前面定义的事件。
###2级DOM
W3C 标准出来之前各家浏览器都是百花齐放，按照自己的一套标准来搞，甚至会出现恶性竞争的情况比如 IE 和 netscape 的浏览器大战，同时这两个浏览器采用的也是两种背道而驰的事件模型。在标准出来之后，对事件模型约定了全新的标准，统称为 2级DOM，2级DOM 采用了事件捕获和事件冒泡组合的事件模型来确保浏览器之间的兼容，它把事件的触发分为三个阶段，第一个阶段是捕获阶段，事件流从 document 开始流向目标元素，第二个阶段是处理阶段，这个阶段发生在目标元素中，在这个阶段执行目标元素绑定的事件监听函数，第三个阶段是冒泡阶段,事件流从目标元素流向 document。在 2级DOM 中还新增加了 addEventListener 方法来给元素绑定事件，使用 addEventListener 方法绑定的事件可以在三个阶段中的任何一个阶段触发，addEventListener 接收三个参数，第一个是事件类型，第二个是事件监听函数，第三个是一个布尔值，用来决定事件在哪个阶段触发，true 表示在任意阶段都可以触发，false 表示在捕获阶段不能触发。使用 addEventListener 方法可以给同一个元素绑定多个事件，并不会出现 0级DOM 里那种函数覆盖的情况。
```javascript
//代码实例
var btn = document.getElementById('btn');
btn.addEventListener('click', function(e){
    //do something...
}, false);    
```
###事件对象
在 0级DOM 和 2级DOM 定义的事件监听函数中都有一个默认参数，它是一个在函数触发时自带的事件对象，这个对象包含了事件触发的一些必要信息，比如事件触发的元素，当时鼠标所处的位置信息以及键盘按键信息等，有了事件对象，我们就可以解决一些常见的 DOM 操作问题，如果我有一个列表，初始有三个列表项，并且这个列表项是动态的，会根据用户的添加和删除操作增减列表项，我要给这个列表中的所有列表项都绑定一个点击事件，这个时候如果我们直接使用普通方法给列表项绑定事件的话那么在增加了新的列表项之后该新增项将不会被绑定事件，原因是 JavaScript 只执行一次，当你新增了列表项之后绑定点击事件的代码并不会重新运行一次。我们可以利用事件冒泡和事件对象来解决这个问题，当点击事件发生的时候，我们让事件往上冒泡，一直冒泡到 document 元素，然后事先在 document 元素上绑定点击事件，让 document 元素来统一处理所有的点击事件，但是光使用事件冒泡还不能够让我们新增的列表项绑定事件，这个时候就要用到事件对象了，事件对象 event 有一个属性 currentTarget，其值是当前事件正在处理的元素，我们可以利用这个来识别当前的元素是不是我们要触发点击事件的元素，如果是的话，就触发，如果不是，就不触发，这样问题就解决了，JQuery 的事件绑定函数 on 里面的实现原理大概也是这样的（当然没这么简单）。




