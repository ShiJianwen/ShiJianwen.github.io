title: 我理解的从输入 url 到浏览器渲染页面的过程
date: 2015-10-25 01:20:10
categories: "Web 开发"

---

&nbsp;&nbsp;&nbsp;&nbsp;最近刚看完《计算机网络》，自己重新整理了一下关于输入 url 后会发生什么的问题，跟以前的理解不同的是现在对整个通信过程有了更多的了解，所以这里会偏重讲一下通信过程和一些概念。
&nbsp;&nbsp;&nbsp;&nbsp;当我们在浏览器中输入一个 url 时，大致会发生这些过程：

### 1.检查输入

&nbsp;&nbsp;&nbsp;&nbsp;首先浏览器会检查你输入的值，确定是不是一个合法的 url，如果不是，浏览器就会调用设置里的默认搜索引擎进行搜索并跳转。

### 2.获取目的 ip

<!-- more -->

&nbsp;&nbsp;&nbsp;&nbsp;这一步的目的是为了获取到目标网站的 ip 地址，因为我们一般输入的url都是域名，就像 ```www.baidu.com``` 这样的，但是浏览器只认识 ip 地址，所以这一步就是要把域名转换成 ip 地址，浏览器首先检查自身的 DNS 缓存，看看有没有这个网站的 DNS 查询记录，如果没有的话就查系统里的 DNS 缓存，如果还是没有呢就通过向自己的 DNS 服务器查询来获得 ip 地址，但是 DNS 服务器又在哪里呢？换句话说，DNS 服务器的 ip 地址又是什么呢？这时候就要说一下 DNS 这个东西了，DNS 的全称叫 Domain Name System 域名系统，目的是为了查询各个域名对应的 ip 地址，我们上网时一个非常重要的参数就是配置 DNS 服务器，以我们学校为例，当我们使用 iNode 客户端登陆校园网系统成功后，学校的 DHCP 服务器就会动态地帮我们分配这些上网的参数，其中包括本机的 ip，当前所处子网的网关服务器地址，子网掩码以及 DNS 服务器地址（关于网关和 DHCP 接下来再解释）。在拿到了 DNS 地址之后，我们访问网站的时候就可以向这个 DNS 服务器发送查询 ip 地址的请求了，DNS 服务器在收到这个请求之后会先检查一下自己的缓存看有没有这个域名的记录，如果有并且还没有过期的话就会把这个当作响应发送给请求的服务器，如果没有的话就要继续向上层 DNS 发出查询了，因特网里的 DNS 呈金字塔状，位于顶层的是根 DNS 服务器，它处理所有发过来的查询请求；再往下一层是顶级域 DNS 服务器，它们按照域名后缀分为 .com服务器、 .net服务器、 .org服务器这些，顾名思义， .com服务器只处理那些域名后缀是 .com 的请求而 .net服务器只处理 .net 域名的请求。权威 DNS 往下是具体到每个域名的次级域 DNS 服务器，也叫权威 DNS 服务器，比如 baidu.com 的 DNS服务器，该 DNS 服务器里面就存着所对应域名的 ip 地址（在这里就是 baidu.com的ip地址）。一般来说，如果 DNS服务器 在自己的缓存中找不到符合响应要求的数据的话就会发一个请求给 根DNS，根DNS 检查你请求的域名然后根据它的后缀发给对应的 顶级域DNS，顶级域DNS 又根据具体的域名发给自己管辖下的 权威DNS，直到找到目标 ip  地址。经过这么复杂的步骤，我们终于拿到了目的地的 ip 地址。

### 3.建立连接

&nbsp;&nbsp;&nbsp;&nbsp;当我们知道了目的地的 ip 之后，就可以向那个地址发送请求了，但是发送请求之前我们需要先建立一个连接，因为我们的浏览器是使用 TCP 协议的，TCP 协议的一个特点就是它是面向连接的，与之相对的一个协议就是 UDP 了，UDP 是一个无连接的协议，这两者各有优缺，也有各自适用的场景，在此不做讨论。建立 TCP 连接的步骤是经过一个叫做 “三次握手” 的通信过程实现的，我们可以简单的理解成这样：首先，浏览器发送一个特殊的 TCP 报文给 baidu.com 的服务器，baidu.com 的服务器收到这个报文后对这个报文进行确认，这是第一次握手，之后服务器会发送一个确认收到这个特殊报文的响应给浏览器，浏览器收到服务器发回来的报文之后就完成了第二次握手，然后浏览器再发送一个确认收到的报文给服务器进行第三次握手，三次握手完毕后即说明连接已经建立好可以发送 http 请求了，一般浏览器在第三次握手的时候发送确认报文的时候也可以同时加入一些真实的资源请求了。

### 4.发送请求，接受响应

&nbsp;&nbsp;&nbsp;&nbsp;经过第三步我们建立了一个基本的 TCP 连接之后，我们就可以开始正常的发送请求和接受响应了，拿我们一开始输入的 url ```baidu.com``` 来说，连接建立之后浏览器会向百度的服务器请求 baidu.com 域名下的首页资源，服务器接收到这个请求后，会根据后台逻辑返回相应的内容给浏览器，比如现在返回一个 html 页面给浏览器，浏览器接收到这个响应后就开始渲染这个页面，在渲染之前浏览器会先扫描一遍页面的结构，把里面引用的一些超链接形式的静态资源（如 CSS，JS，图片等）重新像刚才那样发送请求去请求回来。但是这个请求是有先后顺序的，而且不同的文件类型有不同的加载性质，比如 js 文件加载的时候会阻塞整个页面的渲染，这个时候浏览器必须停下来等待这个 js 加载完毕后才能继续渲染页面，这也是为什么优化建议里会要求我们把 js 文件放到页面底部去加载的原因，就是为了不让 js 的加载阻塞页面渲染，避免导致页面出现一个长时间的空白期，从而提高用户体验。照这么说的话，那么 css 文件能不能放到页面底部来提高网页性能呢？答案是否定的，因为如果把 css 也放在底部，那么在 css 完成渲染之前，页面会停留在一段没有样式的时间内，这会导致用户看到一个完全没有样式的页面，这还不是重点，重点是 css 的下载和渲染是同时进行的，后面下面的 css 会覆盖掉前面定义过的 css，每次覆盖都会重新渲染前面的元素，这也是 css 为什么叫层叠样式表的原因（它就是这样一层叠一层地渲染的）。这样的后果就是重复渲染导致的闪屏，这样对用户来说也是很难忍受的。到此为止，整个请求的流程到渲染就差不多这样了，其中还有很多地方是这里没有详细展开来讲比如 css 渲染的特点、优化建议以及涉及到计算机网络更详细的通信过程之类的，我会在别的文章里专门写出来。 

### 附录：

***什么是 DHCP？***
DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是指在局域网中用来动态给各个用户分配 ip 地址的一个协议，我们在系统中打开本地连接的属性里的 ipv4 面板时：
![此处输入图片的描述][1]


  [1]: http://b.hiphotos.baidu.com/exp/w=480/sign=f1d1578c4d086e066aa83e4332097b5a/bf096b63f6246b60457b79c9eaf81a4c510fa212.jpg
  
  会发现我们可以选择自动获取 ip 地址或者手动配置 ip 地址，这里的自动获取 ip 地址就是指通过 DHCP服务器 来获取 ip地址。使用 DHCP 的目的有两个，一个是刚刚说的动态分配地址，另一个就是方便网络的集中管理。为什么要动态地分配地址？一个是为了减轻网络管理员的工作，避免手动地去配置每台机器的地址，另一个也是为了避免人工配置失误引起的地址冲突，另外一个，拿学校举例子，如果学校有两万个终端用户，突然有一天学校把校园网从电信网换成了网通网，因为不同的网络供应商使用的 ip 地址块是不一样的，所以一旦这种情况发生，在没有 DHCP 的情况下我们只能给这两万台机器重新配置新的 ip 地址。再另一个，如今接入互联网的设备越来越多，每个上网的设备都需要一个 ip 地址，随着设备数量的爆炸增长，总有一天 ip 地址会不够用，事实是现在 ip 地址已经完全不够了，因为 ip 地址的长度被限定在四个字节，它能提供的 ip 地址数量是有限的，如果要给所有设备都分配一个静态地址实在是有点奢侈，使用 DHCP 的好处就是可以做到按需分配，假如我们学校有两万电脑，但是学校发现我们的在线峰值是一万台机器同时上网，基于这样的事实我们使用 DHCP 就能够节省 ip 地址的开销，即只有当有人上网的时候服务器才从 ip 地址池里面取一个地址出来给这个用户而不是让这个用户永远占据这个地址。如今为了解决 ip 地址短缺的问题，因特网推出了新的 ip 地址 ipv6，它的一个主要变化就是长度变得更长了，能够分配更多的 ip 地址了。
  
***什么是网关？***
网关就是一个局域网内特殊的路由器，就好像我们要出大学城要经过收费站那样，每一个从局域网发出到公共因特网上以及从公共因特网上要发到局域网里头的请求都要经过网关路由器的跳转才能完成，它相当于一道关卡，守着本地局域网跟公共因特网之间的接口，一夫当关，万夫莫开。网关路由器的地址在你的主机向 DHCP 请求连接的时候会和 ip 地址这些配置参数一同发送给你的主机。

***什么是子网掩码？***
我们发现连同 ip 地址和网关地址发过来的还有一个叫做子网掩码的东西，它跟 ip 一样是 32 位长，使用子网掩码的目的是区分一个 ip 地址的对外部分（网络地址）和对内部分（主机号）。对外部分是用来识别具体到哪一个局域网的，这部分是不变的；对内部分是用来识别局域网内具体到哪一台主机的，其中对外部分用 1 标识，对内部分用 0 标识，假如我一个局域网一共有 7 个 ip，分别是 192.168.1.249 到 192.168.1.255，化解成 32 位的 ip 地址就是 ```11000000.10101000.00000001.11111001``` 到 ```11000000.10101000.00000001.11111111``` 可以看到我这一个局域网里头的 ip 地址变化只是体现在最后 3 位上，所以这里对外部分就是前 29 位，对内部分就是后 3 位，分别用 0 和 1 进行标识可以得到子网掩码位 ```11111111，11111111，11111111，11111000``` 转换成十进制就是 255.255.255.248，这就是我们要的子网掩码。当一个数据报在公共因特网上广播的时候，各个局域网的网关都会收到这个数据报，这时候网关就会把数据报的目的地址和自己的子网掩码匹配从而确定这个数据报是不是发给自己局域网内的，如果是则接收，否则丢弃，这样能够极大地提高局域网的安全性，也能及时拦截那些不是发给自己的数据报，避免浪费性能。
