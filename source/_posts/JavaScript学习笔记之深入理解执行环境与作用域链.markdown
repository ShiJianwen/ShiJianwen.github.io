title: JavaScript学习笔记之深入理解执行环境与作用域链
date: 2015-04-06 15:33:10
categories: "JavaScript"

---
##执行环境和作用域链
&emsp;&emsp;执行环境和作用域链是 JavaScript 里最重要的一个概念，在讲它们之前，先简单解释一下两个名词：‘变量对象’和‘活动对象’。

&emsp;&emsp;**变量对象**
&emsp;&emsp;变量对象是当代码执行流进入作用域时创建的一个包含该作用域内所有变量和函数声明的对象（**注意：函数表达式不在此列**）。
&emsp;&emsp;**活动对象**
&emsp;&emsp;活动对象是函数执行时创建的一个对象，这个对象包含函数的形参以及所有局部变量，它跟上面的变量对象正好是相对关系。
<!-- more -->

&emsp;&emsp;在 JavaScript 里，执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为（***比如在一个函数内部是无法访问该函数的子函数的内部变量的，因为在这个父函数的执行环境里没有定义子函数中的任何数据***）。每个执行环境都有自己对应的一个变量对象，全局环境是处于最外围的一个执行环境（***一般认为就是 Window 对象***），当一个执行环境的所有代码执行完之后，该执行环境和它里面的变量都会被销毁（***全局环境在应用程序退出时才会被销毁***）。每个 JavaScript 函数也都有自己的执行环境，当代码执行流进入一个函数时，函数的执行环境会被压入环境栈里，直到函数执行完毕才会将其弹出，并把控制权交给之前的执行环境。
&emsp;&emsp;当代码执行流进入一个环境时，会创建一个该环境变量对象的作用域链（***如果遇到函数则用函数环境中的活动对象当做变量对象***），用来保证访问变量和函数的顺序（***就像变量查找一样，首先会在当前作用域查找，如果没有，再去父作用域找***）。当前执行环境的变量对象始终位于作用域链的最前端，往后一个变量对象是当前执行环境的外部环境，再后一个变量对象则是更外面的环境，这样一直延续到全局执行环境，就形成了一条完整的作用域链，要注意全局环境的变量对象始终都是作用域链中的最后一个对象。
&emsp;&emsp;变量查找的过程就是沿着作用域链从最前端开始一级一级往后查找的过程，一直到全局作用域为止，如果全局环境中依然没有定义这个变量，那么就会返回 Undefined 或者严格模式下报错。同时由于执行环境的存在，使得父作用域无法访问子作用域，而子作用域却能够访问父作用域中的任何变量和函数。

&emsp;&emsp;试分析以下代码

    var name = "Sibarone";
    function Func1 () {
        var age = 20;
        function Func2 () {
            var tempName = name;
            console.log("My name is " + tempName + "," + age);
        }
        Func2();
    }
    Func1();

&emsp;&emsp;上面的代码一共包含了三个执行环境，分别是 Func2、Func1 和全局执行环境，全局环境里的变量对象包含了变量 `name` 和函数 `Func1`；Func1的执行环境里定义了变量 `age` 和函数 `Func2`，同时该环境可以访问全局环境里的所有变量；Func2的执行环境里定义了变量 `tempName`，这个变量只能在该环境被访问，无法被外部环境访问，但是这个环境可以访问它的所有外部环境的变量，外部的任何变量对它都是公开的。

##延长作用域链
&emsp;&emsp;JavaScript 的作用域链除了局部环境和全局环境的组合之外，还可以人为延长作用域链，具体来说，就是当代码执行流进入 `with` 或者 `try...catch` 语句时，作用域链都会得到延长：

&emsp;&emsp;***with语句***
&emsp;&emsp;在 JavaScript 中，with 语句用于设置代码当前对象的执行环境，用代码表示如下：

    var name = "Sibarone"; //全局定义一个变量
    var someObject = {
        name: "ShiJianwen" //定义一个内部变量
    }
    with (someObject) {
        console.log(name); //输出”ShiJianwen“；
    }
    console.log(name);    //输出”Sibarone“
    
&emsp;&emsp;上面的代码中有两个输出语句，正常情况下都是应该输出 Sibarone 的，因为它是一个全局变量，但是使用了 with 语句后当前代码的执行环境被强行变成了 someObject，所以此时在 with 语句里输出的名字就应该是 someObject 中定义的 name 变量。到这里我想大家都明白 with 延长作用域链的原理了吧？其实就是 with 语句在更改执行环境的时候会把这个执行环境的变量对象推入到作用域链的最前端，上面代码就是把 someObject 的环境的变量对象推到整个作用域链的最前端，使得变量查找的时候在作用域链的最前端就能找到 name 变量，这样就不会访问到全局的 name 变量了。

&emsp;&emsp;***try...catch语句***
&emsp;&emsp;try 和 catch 语句在 JavaScript 中总是成对出现的，它们的作用主要是检查代码的语法错误，拼写错误和各种不可预知因素导致的错误。try 语句用来测试代码的错误，catch 语句用来处理错误，经常跟 try...catch 一起使用的还有 throw 语句，throw 语句主要用来抛出错误，完成自定义的错误提示。更多关于 try...catch 语句的知识可以看[这里][1]。在运行 try...catch 语句的时候，catch 语句块的执行环境会生成一个新的变量对象加入到作用域链的前端从而达到延长作用域链的目的。用代码表示如下：

    try {
        allert("abc");  //写一段出错的代码
    }
    catch (err) {   //错误被捕捉到后会执行这里的 catch 语句
        console.log(err.message);   //访问错误对象，输出错误信息
    }
    console.log(err.message); //报错 not defined，无法访问

&emsp;&emsp;如果你对我刚刚说的变量查找规则还有点印象的话那相信你也看懂了在这里 catch 语句确实延长了作用域链，在变量查找的过程中，总是会先从作用域链的最前端开始查起，一直追溯到全局环境的变量对象，在上面的代码中，假设如果 catch 语句没有延长作用域链，那么我在最后一行（catch 语句外部）输出错误信息时应该是不会报错的（***因为 JavaScript 没有块级作用域这一说法，`注1` 解释这点***），因为大家都处于同一个作用域中，变量查找是能找到本作用域的所有变量的，但事实却是代码报错，想想变量查找的时候为什么会报错？原因就是真正 err 对象根本不在本作用域里！也不在父作用域里，它被定义在当前输出环境的子作用域里，也就是作用域链的最前端！它里面的错误对象组成了一个新的变量对象然后被加到作用域的最前端。这就证明了代码的作用域的确是被延长了。

&emsp;&emsp;注1：在类 C 语言中，由花括号封闭的代码会形成自己的块级作用域（JavaScript 叫它执行环境），在花括号外部是无法访问花括号内部的任何变量的，但是在 JavaScript 中没有块级作用域这一说法，在花括号外部依然能够访问花括号内部的变量，当然函数的花括号除外，因为函数有自己的执行环境。同样要注意的是在讲 catch 语句能够延长作用域链时只是针对 catch 语句捕获的错误对象 err 来说的，如果在 catch 语句块里面定义一个变量，在 catch 外还是能够访问的，原因同上（块级作用域问题）。
&emsp;&emsp;注2：在 IE8 及其之前版本中，catch 语句执行后捕获到的错误对象不会被新增进一个变量对象然后加入作用域链前端，而是直接被加到当前执行环境的变量对象中去，所以在 catch 语句外部也能访问错误对象 err，但在 IE9 中修复了这个 Bug。
  [1]: http://www.w3school.com.cn/js/js_errors.asp