<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【译】使用 ndb 调试 node 应用]]></title>
      <url>http://shijianwen.github.io/2018/09/30/ndb/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://nitayneeman.com/posts/debugging-nodejs-application-in-chrome-devtools-using-ndb/" target="_blank" rel="noopener">Debugging Node.js Application Using ndb</a></p>
</blockquote>
<blockquote>
<p>Google Chrome 实验室发布了一款新的 node debug 工具来提升开发者体验，本文将会全面介绍 ndb 这款 node 工具</p>
</blockquote>
<p>熟悉 node 的人可能知道，node 一直支持一个无头调试工具:</p>
<p><img src="https://qpic.url.cn/feeds_pic/ajNVdqHZLLApzPeccD5DzWfU7farOgGkl30x5CyEqC1MDibmZBYWBfQ/" alt="node 原生无头调试器"></p>
<p>它使用了一个已经被弃用的协议叫做 V8 调试器协议，并且它并不算是一个功能完备的调试器，只有一些简单的检查功能。</p>
<p>过去在这种情况下，一个新的基于 V8 调试器协议和 Blink 的调试工具出现在开发者眼前，它能够允许我们在任何一个 Webkit 内核的浏览器 DevTools 上面调试我们的 node 应用，是的，它就是 node-inspector，它的出现大幅增加了我们调试 node 应用的效率。</p>
<p>在 node 的 V6.3.0 版本中，V8 Inspector 作为一个实验特性被加入到这个版本中，它带来了一个非常强大的调试协议，同时还集成了 Chrome 的 DevTools 并且支持非常多的新特性如Blackbox、profiling、workspaces和sourcemap等等。此外，它并不依赖已经被弃用的 V8 调试器协议，而是直接基于 Chrome 的调试协议，因此它可以直接跑在调试客户端里面，像 Chromium 内核浏览器、VSC ode、WebStorm这些。启动它也非常简单，只需要输入命令 <code>node --inspect scrip.js</code> 即可。</p>
<p>在 7.20 号的时候，一个叫做 ndb 的全新 node 调试工具也同步开源了。</p>
<p>有新的 node 调试工具的确令人振奋，但这个新的 ndb 拥有哪些新特性呢？</p>
<a id="more"></a>
<h2 id="ndb-出现的背景"><a href="#ndb-出现的背景" class="headerlink" title="ndb 出现的背景"></a>ndb 出现的背景</h2><p>首先附上 ndb 的官方定义：</p>
<blockquote>
<p>ndb is an improved debugging experience for Node.js, enabled by Chrome DevTools<br>（ndb 是一次对 node 调试体验的升级，Chrome DevTools 原生支持 ndb）</p>
</blockquote>
<p>从上面的定义中，我们可以发现：</p>
<ol>
<li>ndb 能够提升调试体验</li>
<li>Chrome DevTools 原生支持 ndb，意味着它使用的是 Chrome 的调试协议，类似于 V8 Inspector</li>
<li>ndb是谷歌 Chrome 实验室维护的</li>
</ol>
<p>因此，你可能认为 ndb 只是提供了一个升级版的 V8 Inspector ，然而事实并非如此。</p>
<p>我们可以发现，使用 V8 Inspector 和 Chrome DevTools 有两个前提：一是 node 版本要大于 6.3.0，另一个是必须要用 Chrome 或者 Chromium 内核的浏览器。如果我们不满足这两个条件或者想在非 Chromium 内核下调试的话怎么办呢？</p>
<p>前面我们没说到 ndb 的使用依赖什么环境，它依赖一个叫做 <code>Puppeteer</code> 的包，Puppeteer 是一个通过 Chrome DevTools 协议来控制 Chromium 的包，它提供了很多封装好的接口。</p>
<center><br><br><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM4FhfQWKaBM0IP6ZRQKQlVgTouqWQpibLvoGYBq1H0GgUw/" alt="Puppeteer is a dependency of ndb"><br><br></center>

<p>当 ndb 安装了 Puppeteer 之后，一个最新的与当前环境兼容的 Chromium 也被安装到了依赖包里。</p>
<p>因为是独立安装的，所以 ndb 不依赖操作系统的浏览器，这种对浏览器不依赖的特性也成为了 ndb 的一个优势。</p>
<p>但它同时也带来一个问题，那就是 node_modules 会比较大，毕竟里面有一个 Chromium。</p>
<p>那么 ndb 在调试上的体验如何呢？</p>
<h2 id="探索ndb"><a href="#探索ndb" class="headerlink" title="探索ndb"></a>探索ndb</h2><p>第一步我们先用 express 建一个 node 应用 demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; res.send(<span class="string">'Hello World!'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.info(<span class="string">'Example app listening on port 3000!'</span>));</span><br></pre></td></tr></table></figure>
<p>再在 package.json 定义一个运行脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"node app.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><p>首先我们在全局环境或者本地安装 ndb。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install -g ndb</span><br></pre></td></tr></table></figure>
<h3 id="启动ndb"><a href="#启动ndb" class="headerlink" title="启动ndb"></a>启动ndb</h3><p>我们有好几种方法启动 ndb：</p>
<h4 id="1️⃣-直接执行文件"><a href="#1️⃣-直接执行文件" class="headerlink" title="1️⃣  - 直接执行文件"></a>1️⃣  - 直接执行文件</h4><p>我们可以通过直接用 ndb 命令执行一个文件来开启 ndb，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">ndb</span> <span class="selector-tag">app</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure>
<p><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM53dKibCr4eYObJ8PHomd0qAHpCaJfkD7JUd3074MkPt1A/" alt="Debugging a script file directly"></p>
<h4 id="2️⃣-运行一个二进制可执行文件"><a href="#2️⃣-运行一个二进制可执行文件" class="headerlink" title="2️⃣ - 运行一个二进制可执行文件"></a>2️⃣ - 运行一个二进制可执行文件</h4><p>有时候我们想要用 ndb 来调试一些可执行二进制文件启动的服务，如 npm 脚本、webpack、单元测试这些。</p>
<p>只需要执行如下命令：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ndb <span class="built_in">npm</span> start</span><br></pre></td></tr></table></figure>
<p>上面我们用 ndb 运行了一个 npm 脚本，同样的，只要配置妥当我们还可以运行 <code>ndb webpack</code> 或 <code>ndb mocha</code> 等命令</p>
<p><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM6KiaaY5icSmrOHibLUC6ws55tW8ibnXsem7oDXmwAYb2LJicg/" alt="Debugging by running npm script"></p>
<h4 id="3️⃣-运行一个项目"><a href="#3️⃣-运行一个项目" class="headerlink" title="3️⃣ - 运行一个项目"></a>3️⃣ - 运行一个项目</h4><p>如果我们只是需要打开一个 ndb 服务，可以直接在项目目录里面执行 <code>ndb .</code> 来打开，这个命令允许我们在执行脚本之前设置断点、编辑文件或其他任何东西。</p>
<p><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM61pUyUWsSOc4Dwbswso2LKAF49WygwWhgA2aB5mzznJw/" alt="Debugging a project"></p>
<p>PS：接下来的示例我们都采用第三种启动方法来示范</p>
<h3 id="放置断点"><a href="#放置断点" class="headerlink" title="放置断点"></a>放置断点</h3><p>在调试的时候放置断点非常简单</p>
<p><img src="https://qpic.url.cn/feeds_pic/ajNVdqHZLLBAK93Uqhfjz4152uwlzeQtUViclM7tiawtxfNsOadybEaw/" alt="Placing a breakpoint on the HTTP response"></p>
<p>我们可以在模块被实际加载之前就放置断点</p>
<h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><p>使用 Chrome DevTools，我们可以在项目中创建和编辑文件，并将它们保存</p>
<p><img src="https://qpic.url.cn/feeds_pic/ajNVdqHZLLBmnHl7odggDfFWPfIGWD5cic8hLpH02sZ03PVy46QAOrQ/" alt="Changing the source code of a script file
"></p>
<h3 id="运行-npm-脚本"><a href="#运行-npm-脚本" class="headerlink" title="运行 npm 脚本"></a>运行 npm 脚本</h3><p>如果项目中包含一些 npm 脚本，可以通过 ndb 的面板中运行</p>
<p>![Running an npm script]<a href="https://qpic.url.cn/feeds_pic/ajNVdqHZLLCCqn70fPBokRibIfgaMI0CmRA12NrqaEziadRICOVvl8iaA/" target="_blank" rel="noopener">https://qpic.url.cn/feeds_pic/ajNVdqHZLLCCqn70fPBokRibIfgaMI0CmRA12NrqaEziadRICOVvl8iaA/</a>)</p>
<h3 id="内置终端"><a href="#内置终端" class="headerlink" title="内置终端"></a>内置终端</h3><p>通过 ndb 也可以直接访问终端</p>
<p><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM6vpUibtDxHJljiagXjRXXibwSmiafvtyVIjtrPQo7SDQqtfg/" alt="Opening the built-in terminal panel"></p>
<h3 id="Blackboxing"><a href="#Blackboxing" class="headerlink" title="Blackboxing"></a>Blackboxing</h3><p>在默认情况下，ndb 会屏蔽一些外部文件，如 node 内置库，我们调试的时候对这些外部文件并不需要关心</p>
<p><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM4wvA0hVIP6MnD5AibIT35ezbjovw9fqibKhJ75fBQ5Gufw/" alt="Blackboxing the module loader of Node.js"></p>
<h3 id="进程面板"><a href="#进程面板" class="headerlink" title="进程面板"></a>进程面板</h3><p>这个面板会列出当前由 ndb 启动的所有 node 进程。此外，子进程会收拢到它的父进程中，方便管理和终止</p>
<p><img src="https://qpic.url.cn/feeds_pic/ajNVdqHZLLB9ZtAVpkH5X9dEwdSxchd4VfsEIiaNIC7uPbhve4liarFw/" alt="Terminating a child and parent process by single click"></p>
<h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p>ndb 支持创建一些代码片段来执行和调试</p>
<p><img src="https://qpic.url.cn/feeds_pic/ajNVdqHZLLDh8ickQzgN576V99756qxNSq9WhErXp6nqxvlY0uzLBHA/" alt="Creating and executing a snippet"></p>
<h3 id="变量访问"><a href="#变量访问" class="headerlink" title="变量访问"></a>变量访问</h3><p>当前进程变量和 node 的全局变量，ndb 都可以访问到</p>
<p><img src="https://qpic.url.cn/feeds_pic/Q3auHgzwzM5IRAVnoQE9aBsLFW2hdYck77KrlqQAmI2ARicmPx9OU9A/" alt="Logging `process` object to Console"></p>
]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 好东西 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flutter 初探]]></title>
      <url>http://shijianwen.github.io/2018/04/02/flutter/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对应用开发来说，跨平台是一个永恒的话题，无数工程师们在不断地探索技术的边界，使业界涌现了一批又一批优秀的跨平台开发框架，Flutter 就是其中的一员。本文旨在介绍 Flutter 的初阶使用，如果大家有兴趣，后面会陆续输出一些深入的文章。</p>
</blockquote>
<h2 id="什么是Flutter"><a href="#什么是Flutter" class="headerlink" title="什么是Flutter"></a>什么是Flutter</h2><p>Flutter 是由 Google 开源的一个全新的跨平台开发框架，致力于让开发者可以通过它在 iOS 和 Android 两个平台开发原生应用，同时能够在跨平台的基础上较好地保证应用的性能和质量。</p>
<blockquote>
<p>Flutter 官网：<a href="http://flutter.io" target="_blank" rel="noopener">http://flutter.io</a></p>
</blockquote>
<h2 id="Flutter的特点"><a href="#Flutter的特点" class="headerlink" title="Flutter的特点"></a>Flutter的特点</h2><a id="more"></a>
<p>先以前端工程师熟悉的 RN 举例，RN 是典型的通过驱动原生 UI 组件进行开发的跨平台框架，得益于 React 本身的 VDOM 设定，使得在 RN 中，上层的 DSL 只需关注如何使用 VDOM 去描述 UI 界面，然后由不同平台的 renderer 进行 VDOM 的绘制来达到跨平台的目的。一个简单的架构图如下：<br><img src="http://7xawh4.com1.z0.glb.clouddn.com/1609086-88b683f05674b315.jpeg" alt="1609086-88b683f05674b315"><br>上图 VDOM 和 renderer 之间，通过一层 bridge 通信来交换 UI 信息和对应的事件信息，可以看出这种跨平台的方式有它天然的瓶颈，那就是 js 和 native 之间通信的成本和性能消耗，特别是在一些动画和富交互的场景中，想要达到流畅的标准（60fps），很容易会碰到性能问题，在低端机器上的表现更是不忍直视（这个问题业界也有一些优化方案，阿里给 weex 出过一个 BindingX 的解决方案，里面的 express-binding 专门为了解决这个问题，但是感觉舍弃了一些灵活性和控制性，具体不展开了）。</p>
<p>再说回 Flutter，相比于 RN，Flutter 可以说完全是另外一种风格，这里捡几个重要的点说下。首先，为了避免使用 bridge 通信导致出现明显的性能瓶颈，Flutter 使用 Dart 语言编译成了不同平台的原生代码，直接与平台通信，并且原生代码也让应用的性能更加出色；另外在 UI 上 Flutter 也做了突破，它不再依赖原生的 UI 组件，所有组件都由 Flutter 在框架层面上提供，并且支持各种拓展和定制，然后由 Flutter Engine 绘制在真实的画布上，这个过程只需要平台提供 canvas 能力即可，同时因为 UI 完全可控，使得 Flutter 有更好的兼容性。</p>
<p><img src="http://7xawh4.com1.z0.glb.clouddn.com/15225939129608.jpg" alt=""></p>
<p>（上图除了底层的 Flutter Engine，其他都是可以由开发者自由定制）<br>说完了 Flutter 的亮点，再说说一个令人担忧的点，那就是应用的动态性。目前来看，Flutter 应用因为是编译出来的，不能像 RN 那样动态加载 js 文件然后执行。不过跨平台跟动态化本身就是两件事情，Flutter 目前也才 beta，未来发展如何也未可知。</p>
<h2 id="如何入门"><a href="#如何入门" class="headerlink" title="如何入门"></a>如何入门</h2><ul>
<li>安装 flutter</li>
</ul>
<p><code>git clone -b beta https://github.com/flutter/flutter.git</code></p>
<ul>
<li>配置开发环境</li>
</ul>
<p>可以通过 flutter doctor 命令检查当前开发环境配置，并按照提示安装即可，Flutter 可以在 Android Studio 、 Xcode 和 VSCode 里面搭配 Flutter 插件跑，也可以用编辑器 + Shell 跑，IDE 配置详见：<a href="https://flutter.io/get-started/editor/" target="_blank" rel="noopener">https://flutter.io/get-started/editor/</a><br><img src="http://7xawh4.com1.z0.glb.clouddn.com/15219789336660.jpg" alt=""></p>
<p><img src="http://7xawh4.com1.z0.glb.clouddn.com/15219817737408.jpg" alt=""></p>
<ul>
<li>初始化项目</li>
</ul>
<p>终端执行 <code>flutter create myapp</code> 命令或者 IDE 里面新建 Flutter 项目，然后终端执行 <code>flutter run</code> 或者 IDE 里启动调试即可预览 Flutter 应用<br><img src="http://7xawh4.com1.z0.glb.clouddn.com/15225969203941.jpg" alt=""><br>更多入门细节请移步 <a href="https://flutter.io/get-started/install/" target="_blank" rel="noopener">https://flutter.io/get-started/install/</a></p>
]]></content>
      
        <categories>
            
            <category> 移动开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[centos 7 配置 lnmp 环境]]></title>
      <url>http://shijianwen.github.io/2017/11/15/centos%207%20%E9%85%8D%E7%BD%AE%20lnmp%20%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近折腾 vps 的迁移，各种环境要重新部署，查各种文档让人头疼，年久失修的文档真是害人不浅，于是折腾好环境之后将各个有效的文档做一遍整合，看看 CentOS 7 64 位环境下怎样搭建 LNMP 环境</p>
</blockquote>
<h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><h4 id="1-gcc"><a href="#1-gcc" class="headerlink" title="1. gcc"></a>1. gcc</h4><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p>
<a id="more"></a>
<p><code>yum install gcc-c++</code></p>
<h4 id="2-PCRE-pcre-devel"><a href="#2-PCRE-pcre-devel" class="headerlink" title="2. PCRE pcre-devel"></a>2. PCRE pcre-devel</h4><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：<br><code>yum install -y pcre pcre-devel</code></p>
<h4 id="3-zlib"><a href="#3-zlib" class="headerlink" title="3. zlib"></a>3. zlib</h4><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p>
<p><code>yum install -y zlib zlib-devel</code></p>
<h4 id="4-OpenSSL"><a href="#4-OpenSSL" class="headerlink" title="4. OpenSSL"></a>4. OpenSSL</h4><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p>
<p><code>yum install -y openssl openssl-devel</code></p>
<h3 id="下载-nginx-包"><a href="#下载-nginx-包" class="headerlink" title="下载 nginx 包"></a>下载 nginx 包</h3><p>在 <a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a> 手动下载安装包或者使用 wget 命令获取对应版本的安装包：<br><code>wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</code></p>
<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf nginx-1.10.1.tar.gz
cd nginx-1.10.1</code></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>./configure</code></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p><code>make</code><br><code>make install</code></p>
<p>启动这些不用我写了吧？</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>附上一个支持 php 的 nginx 配置：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span>        <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span>   nginx.ninghao.net;</span><br><span class="line">  <span class="attribute">root</span>          html;</span><br><span class="line">  <span class="attribute">index</span>         index.php index.html;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">    <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 PHP</h2><p>如果你对 PHP 没有特殊版本要求的话，直接执行以下命令即可，不然还需要小心分辨不同版本</p>
<h3 id="安装-PHP-1"><a href="#安装-PHP-1" class="headerlink" title="安装 PHP"></a>安装 PHP</h3><p><code>yum install php</code></p>
<h3 id="安装-PHP-扩展包"><a href="#安装-PHP-扩展包" class="headerlink" title="安装 PHP 扩展包"></a>安装 PHP 扩展包</h3><p><code>yum install php-mysql php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt</code></p>
<h3 id="安装-php-fpm"><a href="#安装-php-fpm" class="headerlink" title="安装 php-fpm"></a>安装 php-fpm</h3><p><code>yum install php-fpm</code></p>
<p>用命令 <code>systemctl start php-fpm</code> 启动 php-fpm，看看现在 9000 端口有没被监听，有的话就可以写个 php 文件试试看了</p>
<h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>最简单就是安装 MySQL 啦。</p>
<p><code>yum install mysql mysql-server</code></p>
<p>然后设置 root 用户密码，先用 root 身份登录 mysql</p>
<p><code>mysql -u root</code></p>
<p>进去后设置密码：</p>
<p><code>use mysql;</code><br><code>UPDATE user SET Password=PASSWORD(&#39;newpassword&#39;) WHERE user=&#39;root&#39;;</code><br><code>exit;</code></p>
<p>重启 mysql 服务</p>
<p><code>sevice mysqld restart</code></p>
<p>搞定！</p>
<p>参考文章：</p>
<p><a href="http://www.linuxidc.com/Linux/2016-09/134907.htm" target="_blank" rel="noopener">CentOS 7 下安装 Nginx</a></p>
<p><a href="http://www.linuxidc.com/Linux/2014-12/111030.htm" target="_blank" rel="noopener">CentOS 6.5系统安装配置LAMP(Apache+PHP5+MySQL)服务器环境</a></p>
<p><a href="https://ninghao.net/blog/1368" target="_blank" rel="noopener">在阿里云 CentOS 服务器（ECS）上搭建 nginx + mysql + php-fpm 环境</a></p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo接入来必力评论系统]]></title>
      <url>http://shijianwen.github.io/2017/11/09/hexo%E6%8E%A5%E5%85%A5%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>大家好，我又双叒叕换评论系统了，换评论系统似乎成了一个月经贴 orz 。。。（原来的要是好用我也不至于换啊丢！）</p>
<p>好了，话不多说，之前用的基于 Github issue 的 Gitment 评论，它的蛋疼之处在于每篇文章都要自己手动初始化，而且有诸多限制。</p>
<p>再说回这个来必力，可以理解为一个韩国版的多说，多说生前有多好用不用我说了吧？于是怒换之！</p>
<a id="more"></a>
<p>换评论系统嘛，老三步，首先去 <a href="http://www.laibili.com.cn/" target="_blank" rel="noopener">官网</a> 注册个账号，然后进管理页面获取代码，这个来必力的后台隐藏地贼深，一般人找不到，这里直接给你链接啦：<a href="http://www.laibili.com.cn/insight" target="_blank" rel="noopener">http://www.laibili.com.cn/insight</a> 进入获取评论代码，丢到你的博客文章的模板页里面去，至于怎么搞，相信聪明的你一定懂~</p>
<p>这里贴一个写得比我详细比我优雅的文章，具体操作方法可以看这里：<a href="https://zengmianhui.github.io/2017/05/02/hexo%E4%BB%8E%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E8%BD%AC%E4%B8%BA%E9%9F%A9%E5%9B%BD%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA/" target="_blank" rel="noopener">https://zengmianhui.github.io/2017/05/02/hexo%E4%BB%8E%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E8%BD%AC%E4%B8%BA%E9%9F%A9%E5%9B%BD%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA/</a></p>
]]></content>
      
        <categories>
            
            <category> 博客日志 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[移动 Web 下 fixed 定位问题]]></title>
      <url>http://shijianwen.github.io/2017/09/28/fixed-position-issue/</url>
      <content type="html"><![CDATA[<h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><p>移动 web 下，当父元素使用 translate 或者 rotate 旋转的时候，它的所有子元素的 fixed 定位都不生效（据说连 background-attachment 里面的 fixed 也会失效）</p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>浏览器的 bug</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><a id="more"></a>
<h3 id="1-别用-translate"><a href="#1-别用-translate" class="headerlink" title="1. 别用 translate"></a>1. 别用 translate</h3><p>但一般我们会用 translate 来开启硬件加速，如果为了避免这个问题而舍弃硬件加速似乎有点得不偿失</p>
<h3 id="2-模拟-fixed"><a href="#2-模拟-fixed" class="headerlink" title="2. 模拟 fixed"></a>2. 模拟 fixed</h3><p>可以花点心思，用 absolute 来模拟 fixed 定位，效果一毛一样的，具体文章就自己搜啦</p>
<h3 id="3-元素分离"><a href="#3-元素分离" class="headerlink" title="3. 元素分离"></a>3. 元素分离</h3><p>把需要旋转的元素和需要fixed定位的元素分离，不要呈父子关系，可以尝试把旋转下发到各个子元素上</p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo 使用 Gitment 作为评论系统]]></title>
      <url>http://shijianwen.github.io/2017/09/12/hexo-gitment/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment</a> 是一个基于 Github issue 的博客评论系统，它的原理是利用 Github 官方提供的 api 操作你某个仓库下的 issue，使用 label 来标记不同的文章，因为是基于 Github issue 的，所以只支持 Github 用户登录，不过无妨。调用 Github api 需要用户提供 Github oAuth 鉴权的 id 和密钥，这个可以在 Github 上申请。在这里必须佩服一下作者的脑洞，接连几家第三方评论系统的停止服务，Gitment 的出现的确解了燃眉之急。我的博客是基于 Hexo 搭建的，所以这里简单讲一下怎样在 hexo 博客里使用 Gitment 作为评论系统。</p>
<a id="more"></a>
<h4 id="申请-oAuth-应用"><a href="#申请-oAuth-应用" class="headerlink" title="申请 oAuth 应用"></a>申请 oAuth 应用</h4><p>Gitment 操作 issue 需要进行鉴权，这个鉴权的 id 和密钥要我们自己提供，我们可以在 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">Github Setting</a> 这里申请新的 oAuth 应用，这里都可以随便填，只要注意把最后的 callback url 填成你的博客的 URL（如 <a href="http://blog.shijianwen.com）。申请完成之后会得到一个" target="_blank" rel="noopener">http://blog.shijianwen.com）。申请完成之后会得到一个</a> client id 和 secret，这就是后面鉴权需要用到的东西。</p>
<h4 id="接入博客"><a href="#接入博客" class="headerlink" title="接入博客"></a>接入博客</h4><p>在你博客的主题下，找到文章的模板文件（一般叫做 post.xxx），我用的 hexo 主题是 next，我的路径是 <code>themes/next/layout/post.swig</code>，进入模板文件，引入下面这段代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span></span><br><span class="line"><span class="actionscript">  id: <span class="string">'页面 ID'</span>, <span class="comment">// 可选。默认为 location.href</span></span></span><br><span class="line"><span class="actionscript">  owner: <span class="string">'你的 GitHub ID'</span>,</span></span><br><span class="line"><span class="actionscript">  repo: <span class="string">'存储评论的 repo'</span>,</span></span><br><span class="line"><span class="undefined">  oauth: &#123;</span></span><br><span class="line"><span class="actionscript">    client_id: <span class="string">'你的 client ID'</span>,</span></span><br><span class="line"><span class="actionscript">    client_secret: <span class="string">'你的 client secret'</span>,</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="actionscript">gitment.render(<span class="string">'container'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里有几个注意点，如果你跟我一样是 next 主题用户，那么建议你最好把代码引入到 <code>block content</code> 下。另外在 js 代码里，id 最好使用 location.pathname，保证唯一性的情况下还不会被别的干扰（之前用location.href，如果 url 带 hash 会被认为是两篇不同的文章），如果你有更好的标识方法请忽略这条。</p>
<h4 id="初始化评论"><a href="#初始化评论" class="headerlink" title="初始化评论"></a>初始化评论</h4><p>代码添加完成之后，重新生成并部署到 github，打开你的博客，进入文章页，会看到最下面有一个评论框，此时评论框会提示一个未初始化的错误，这时候你需要在这个页面点击 login，然后点击初始化按钮进行初始化，这也是 Gitment 一个比较繁琐的地方，你需要给每篇文章都初始化一次评论，初始化做的工作就是新建一条当前文章的 issue，之后所有的评论都添加到该 issue 下的评论中去。这里有一个地方需要注意，如果你的文章 url 有些字符被 URL<br> 编码了，比如文章名带了空格等特殊字符，在 url 显示的时候被编码了，这时候登录 github 会报一个 callback url 的错误，提示你当前登录的 url 跟你申请 oAuth 鉴权的时候填的 callback 不一样，但实际上是一样的。所以为了避免这个问题，你的文章的 md 文件名字，最好不要出现空格等特殊字符，一般就用英文加连字符号就行，md 文件的名字只影响你文章 url 的显示，不会影响你真实的文章标题，标题还是以 md 文件里面的 title 字段为准。</p>
]]></content>
      
        <categories>
            
            <category> 博客日志 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[pyspider 初探]]></title>
      <url>http://shijianwen.github.io/2017/09/10/pyspider%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p><a href="http://www.pyspider.cn/" target="_blank" rel="noopener">pyspider</a> 是一款强大方便的爬虫框架，如果你有一个需要快速实现的爬虫任务，pyspider 是一个不错的选择。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h4><p>我们使用 pip 来安装 pyspider，pip 安装见<a href="http://pip-cn.readthedocs.io/en/latest/installing.html" target="_blank" rel="noopener">这里</a></p>
<a id="more"></a>
<h4 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h4><p>爬虫在抓取页面的时候经常会遇到需要模拟浏览器行为的问题，如点击、执行加载等。这些问题在 pyspider 里面都需要靠 phantomjs 去解决。phantomjs 可以理解成是一个没有 UI 界面的浏览器，可以通过代码来完成浏览器的所有行为。安装的命令如下：</p>
<ul>
<li>Ubuntu</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install phantomjs</span><br></pre></td></tr></table></figure>
<ul>
<li>Mac</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install phantomjs</span><br></pre></td></tr></table></figure>
<p>依赖安装完成之后我们可以执行 <code>pip install pyspider</code><br>命令安装 pyspider。</p>
<p>Ubuntu 系统如果报错请确保安装了以下依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python python-dev python-distribute python-pip libcurl4-openssl-dev libxml2-dev libxslt1-dev python-lxml</span><br></pre></td></tr></table></figure>
<p>Mac 系统安装过程中可能会遇到一个 <code>Operation not permitted</code> 的错误，具体解决方法看 <a href="http://blog.shijianwen.com/2017/03/26/Mac%20%E5%AE%89%E8%A3%85%20Scrapy%20%E6%8A%A5%E9%94%99/" target="_blank" rel="noopener">这里</a></p>
<p>安装过程没有报错即代表安装成功。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>命令行使用 <code>pyspider all</code>  命令启动 pyspider，参数 all 代表启动所有 pyspider 的插件。启动完成之后会自动打开 pyspider 的 WebUI 界面，我们后面所有的代码编写、调试、结果查看都在这里完成。</p>
<p><img src="http://7xawh4.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-10%20%E4%B8%8B%E5%8D%888.34.08.png" alt="enter image description here"></p>
<p>点击 <code>create</code> 新建一个爬虫任务然后进入代码编辑界面</p>
<p><img src="http://7xawh4.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-10%20%E4%B8%8B%E5%8D%888.41.35.png" alt="enter image description here"></p>
<p>里面有一些预置的代码，分别是：</p>
<p>crawl_config<br>爬虫配置信息，一些公共配置如请求头等</p>
<p>@every(minutes=24*60)<br>设置 on_start 方法执行的频率，这里是一天一次</p>
<p>on_start<br>入口代码</p>
<p>self.crawl<br>新建一个爬虫任务，丢到等待队列里，callback 参数指定爬虫请求返回后的处理函数</p>
<p>@config(age=10<em>24</em>60*60)<br>设置请求过期时间，这里表示十天内相同请求将会被忽略</p>
<p>index_page<br>爬虫请求的响应的处理函数，response 参数是请求的响应，response.doc 是一个类似 jquery 的对象，可以使用 jq 选择器查找文档里的元素</p>
<p>@config(priority=2)<br>优先级，数字越大优先级越高</p>
<p>detail_page<br>另一个处理函数，该函数的返回值将会直接存到 pyspider 的结果数据库中去，在爬虫任务面板点击查看结果查看的就是所有任务的 detail_page 函数返回的结果</p>
<p>以上几个方法是 pyspider 的核心方法，它同时也揭示了爬虫任务的生命周期。利用好这几个方法即可快速完成你的爬虫任务。</p>
<p>在基于以上几个方法写好爬虫代码之后，可以现在代码编辑调试爬虫代码，点击右上角 save 保存代码，然后在左边绿色区域点击 run 运行爬虫代码，在调试阶段，每次抓取并分析之后（也就是每次执行完 detail_page 之后）都会暂停，供开发者进行分析，点击左侧区域下方的几个按钮，可以看到此时不同的信息。<code>enable css selector helper</code> 可以打开 css 选择器；<code>web</code> 按钮可以展示当前页面的 UI，<code>html</code> 按钮可以展示当前页面的 HTML 结构；<code>follows</code> 按钮可以看到此时等待队列里面的所有待抓取的爬虫请求；<code>message</code>按钮可以显示抓取过程中的信息。当分析完毕需要继续执行爬虫的时候，可以在 <code>follows</code> 队列里面选择一个爬虫任务点击执行，即可进入下一个抓取任务。</p>
<p>对于一些动态页面的抓取，爬虫无法直接抓取，需要模仿浏览器的动态加载过程，就需要用到刚刚我们装的 phantomjs 了，使用 phantomjs 很简单，只要在使用 crawl 函数的时候增加一个参数 <code>fetch_type=&#39;js&#39;</code> 即可。</p>
<p>当代码调试完成之后，即可开始运行，点击 <code>save</code> 按钮保存代码，回到 pyspider 的任务列表页，改变任务 status 为 running，点击右侧 run 按钮即可开始执行爬虫代码。progress 里面会实时显示当前爬虫任务的进度，点击右侧 <code>results</code><br> 按钮可以进入结果页面查看当前爬虫的结果（也就是detail_page函数返回的结果）</p>
<p>到这里一个完整的 pyspider 爬虫过程就结束啦，是不是很方便很强大呢？如果希望对 pyspider 了解更多，可以查看它的<a href="http://www.pyspider.cn/book/pyspider/pyspider-Quickstart-2.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css overflow 问题,]]></title>
      <url>http://shijianwen.github.io/2017/09/06/css-overflow-error/</url>
      <content type="html"><![CDATA[<h4 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h4><hr>
<p>当给一个容器设置 <code>overflow-x: hidden</code> 同时 <code>overflow-y: visible</code> 时，垂直方向的的设置总是失效。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css</span></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">4px</span> solid gray;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  <span class="attribute">overflow-y</span>: visible;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"wrap"</span>&gt;</span><br><span class="line">	&lt;<span class="selector-tag">div</span> class=<span class="string">"inner"</span>&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="http://7xawh4.com1.z0.glb.clouddn.com/1504665163676.png" alt="Alt text"></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><hr>
<p>参考 <a href="https://stackoverflow.com/questions/6421966/css-overflow-x-visible-and-overflow-y-hidden-causing-scrollbar-issue" target="_blank" rel="noopener">https://stackoverflow.com/questions/6421966/css-overflow-x-visible-and-overflow-y-hidden-causing-scrollbar-issue</a> 和 w3c 关于 overflow 值的说法 <a href="https://www.w3.org/TR/css3-box/#overflow-x" target="_blank" rel="noopener">https://www.w3.org/TR/css3-box/#overflow-x</a></p>
<blockquote>
<p>The computed values of ‘overflow-x’ and ‘overflow-y’ are the same as their specified values, except that some combinations with ‘visible’ are not possible: if one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then ‘visible’ is set to ‘auto’. The computed value of ‘overflow’ is equal to the computed value of ‘overflow-x’ if ‘overflow-y’ is the same; otherwise it is the pair of computed values of ‘overflow-x’ and ‘overflow-y’.</p>
</blockquote>
<blockquote>
<p>overflow-x 和 overflow-y 的计算值跟给定的值相同，除了某些跟 visible 值的不合理组合：如果其中一个属性的值为 visible，而另一个为 scroll 或 auto，那么 visible 会被重置为 auto 。在 overflow-y 与 overflow-x 值相同的情况下，overflow 的计算值取决于 overflow-x；否则就按上面的规则计算</p>
</blockquote>
<p>当 overflow-x 和 overflow-y 为不同值的时候，值为 visible 的属性总是会被重置为 auto，这也解释了上面为什么垂直方向有滚动条的问题。</p>
<p>在解决问题的过程中发现有另一个说法是说跟 BFC 有关，因为 visible 和非 visible 对 BFC 的产生刚好相反，为了不引起歧义于是加了一条这样的规则（这个看看就好）</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><hr>
<p><strong><em>wrap 包裹</em></strong><br>还是参考 <a href="https://stackoverflow.com/questions/6421966/css-overflow-x-visible-and-overflow-y-hidden-causing-scrollbar-issue" target="_blank" rel="noopener">stackoverflow</a> 的讨论，既然同一个元素里面不能同时设置 overflow-x 和 overflow-y 为对立的值，那么可以加多一个容器，然后分别设置 overflow-x 和 overflow-y</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"> <span class="selector-class">.wrap</span> &#123;</span></span><br><span class="line"><span class="undefined">   height: 400px;</span></span><br><span class="line"><span class="undefined">   width: 200px;</span></span><br><span class="line"><span class="undefined">   border: 4px solid gray;</span></span><br><span class="line"><span class="undefined">   overflow-y: visible;</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"> <span class="selector-class">.wrap2</span> &#123;</span></span><br><span class="line"><span class="undefined">   overflow-x: hidden;</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"> <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="undefined">   height: 500px;</span></span><br><span class="line"><span class="undefined">   width: 300px;</span></span><br><span class="line"><span class="undefined">   background: red;</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>问题解决。</p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
            <tag> 问题解决 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Scrapy 启动报错 'module' object has no attribute 'OP_NO_TLSv1_1]]></title>
      <url>http://shijianwen.github.io/2017/03/26/Scrapy-start-error/</url>
      <content type="html"><![CDATA[<p><img src="http://7xiuuj.com1.z0.glb.clouddn.com/wallheven-python.png" alt=""><br>这个问题是因为 Twisted 的版本引起的，具体查看 <a href="https://github.com/scrapy/scrapy/issues/2473" target="_blank" rel="noopener">issue</a>，解决办法是安装指定版本的 Twisted：<code>pip install Twisted==16.4.1</code>，关于 Twisted，是一个 Python 里面的异步编程框架，具体可见 <a href="https://www.gitbook.com/book/likebeta/twisted-intro-cn/details" target="_blank" rel="noopener">文档</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 上安装 Scrapy 报错，Operation not permitted]]></title>
      <url>http://shijianwen.github.io/2017/03/26/mac-scrapy-error/</url>
      <content type="html"><![CDATA[<p><img src="http://7xiuuj.com1.z0.glb.clouddn.com/wallhaven-423175.png" alt=""><br>这个问题在 <code>OS X El Capitan</code> 普遍存在，后面会说明原因。</p>
<p>前几天在 Mac 上安装 Scrapy，按照官方文档的步骤使用 pip 安装 scrapy 后报一个权限错误<br><code>OSError: [Errno 1] Operation not permitted: &#39;/var/folders/6t/h404bjcd5tb_4q86tpv_251rv_0h0j/T/pip-sYsqDS-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info&#39;</code><br>看起来像是一个普通的权限问题，但问题是即使使用 sudo 命令也还是报相同的错误，搜索之后发现是因为 pip 在更新本机 six 模块的时候，没有权限卸载本机旧版本的 six 模块。网上给出的解决办法是加个 ignore 参数，完整命令如下：<br><code>pip install scrapy --ignore-installed six</code>，忽略本机已安装的 six，这样就可以避免没有权限删除的问题了。使用此命令可以正常安装 Scrapy，安装完成之后运行 Scrapy，发现又报一个引用错误 <code>ImportError: cannot import name xmlrpc_client</code>，搜索之后发现解决办法是要手动删除机子上的 six 模块然后重装机。。。（又回到原地了），这时候我们就不可避免地要弄清楚刚刚那个权限错误是怎么回事了。所以又是一顿查，发现 <a href="http://www.macworld.com/article/2986118/security/how-to-modify-system-integrity-protection-in-el-capitan.html" target="_blank" rel="noopener">这里</a> 有说到新版的 Mac 里面新增了一个 SIP（System Integrity Protection 系统完整性保护）机制，即在底层限制 root 用户的某些权限，让即使是 root 用户也无法删除/修改某些系统核心文件，这样即使在系统完全被黑的情况下也能够保证系统的完整性，这也算是整个电脑的最后一重安全保障。我们这里遇到的问题就是跟 SIP 有关，解决办法就是进入 Recovery 模式关闭它。关闭的具体步骤是，重启 Mac，按住 <code>cmd + R</code>，等待进入 Recovery 界面，在 Recovery 界面唤出命令行，执行以下命令然后重启机器即可：<br><code>csrutil disable</code></p>
<p>重启后就可以正常启动 Scrapy 啦~</p>
]]></content>
      
        <categories>
            
            <category> OS X </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL5.6 内存占用过高问题]]></title>
      <url>http://shijianwen.github.io/2017/03/23/mysql-ram-error/</url>
      <content type="html"><![CDATA[<p>这几天在给 vps 配 LNMP 环境的时候，安装 mysql 选择的是 5.6 版本，使用的时候经常提示连接数据库失败，使用 mysql 登录的时候一直提示找不都 socket 文件（一个启动后会自动生成的文件），后来发现是整个 mysql 进程都挂掉了，使用 <code>service mysqld restart</code> 重启时也一直无响应，去查看日志，发现启动时发生了一个错误：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> mysqld_safe Number of processes running now: <span class="number">0</span></span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> mysqld_safe mysqld restarted</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> [Note] Plugin 'FEDERATED' is disabled.</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: The InnoDB memory heap is disabled</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: Mutexes <span class="keyword">and</span> rw_locks <span class="keyword">use</span> GCC atomic builtins</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: Compressed tables <span class="keyword">use</span> zlib <span class="number">1</span><span class="variable">.2</span><span class="variable">.3</span></span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: Using Linux native AIO</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: Initializing buffer pool, size = <span class="number">128</span><span class="variable">.0M</span></span><br><span class="line">InnoDB: mmap(<span class="number">137363456</span> bytes) failed; errno <span class="number">12</span></span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: Completed initialization of buffer pool</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> InnoDB: Fatal error: cannot allocate memory <span class="keyword">for</span> the buffer pool</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> [ERROR] Plugin 'InnoDB' init <span class="keyword">function</span> returned error.</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> [ERROR] Unknown/unsupported storage engine: InnoDB</span><br><span class="line"><span class="number">140416</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">24</span> [ERROR] Aborting</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注意这个：<code>Fatal error: cannot allocate memory for the buffer pool</code>，说明是内存不足了，因为这时候进程已经挂掉了没办法看到内存占用情况，但我从 vps 的统计报表里面能看到当时的内存占用情况：</p>
<p><img src="http://7xiuuj.com1.z0.glb.clouddn.com/QQ20170323-0.png" alt=""></p>
<p>差不多 400M 的样子，吓得我赶紧搜了一下，结论是 mysql5.6 相对前代性能有大幅提升，但同时内存占用也是水涨船高，对于个人小站点来说，mysql5.6并不适用，所以如果你对数据库不太挑剔的话，还是建议用旧版本吧。如果你坚持使用5.6版本，那么要么升级你的内存，要么在配置文件里限制 mysql 的资源数，在 <code>/etc/my.cnf</code> 文件里面添加如下配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">performance_schema_max_table_instances</span>=<span class="number">400</span>  //检测的表对象的最大数目</span><br><span class="line"><span class="attr">table_definition_cache</span>=<span class="number">400</span>  //能缓存的最大表定义数</span><br><span class="line"><span class="attr">table_open_cache</span>=<span class="number">256</span>  //最多能打开的表数目</span><br></pre></td></tr></table></figure>
<p>配置完成之后用命令 <code>service mysqld restart</code> 重启 mysql 即可。</p>
<p>除此之外，<code>innodb_buffer_pool_size</code>，<code>innodb_additional_mem_pool_size</code>，<code>innodb_log_buffer_size</code> 也可以做相应调整，还有 <code>performance_schema</code> 在 vps 里面没什么意义，可以关掉：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">8</span>M </span><br><span class="line"><span class="attr">innodb_additional_mem_pool_size</span> = <span class="number">1</span>M </span><br><span class="line"><span class="attr">innodb_log_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"><span class="attr">performance_schema</span> = <span class="literal">OFF</span></span><br></pre></td></tr></table></figure>
<p>所以。。。为什么不直接换5.5呢？</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GoodBye Alice]]></title>
      <url>http://shijianwen.github.io/2017/03/23/GoodBye-Alice/</url>
      <content type="html"><![CDATA[<p><img src="http://7xiuuj.com1.z0.glb.clouddn.com/Resident.png" alt=""></p>
<p>等啊等终于让我等来了生化终章的无删减版，工作日晚上熬着夜把电影看完，第二天起床后发现都忘记昨晚看的啥了。。。</p>
<p>明显感觉到影片叙事很匆忙，生硬地把故事收尾。Alice 一行人，连人都没给整明白，就早早领盒饭了。蜂巢里的历险更像是花式陷阱死亡秀，特效也没有特别出彩。整个终章，更像是为了结局而结局。</p>
<p>幸好克莱尔还是辣么美~HIAHIAHIA</p>
]]></content>
      
        <categories>
            
            <category> 电影 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 批判一番 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Clipboard.js 在华为手机中的兼容]]></title>
      <url>http://shijianwen.github.io/2017/03/22/clipboard-fix/</url>
      <content type="html"><![CDATA[<blockquote>
<p>果然大厂的 bug 都要屌一点</p>
</blockquote>
<h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><p>最近接手一个需求，需要实现一个点击复制的功能，当点击触发按钮后，自动将一段文本复制到剪贴板，本着不（jiu）重（shi）复（yin）造（wei）轮（lan）子的想法，我搜索了一番，发现了广受好评的 <a href="https://clipboardjs.com/" target="_blank" rel="noopener">Clipboard.js</a>。了解一番后发现 Clipboard.js 的原理是利用 DOM 提供的 execCommand 方法来执行 copy 命令，不足的是 execCommand 这个 api 并不是所有浏览器都能用，但幸好针对不兼容的浏览器 Clipboard 能够高亮选中文本并提示用户手动复制，达到降级的目的。开发过程中一切都很正常，但在做适配测试的时候，部分华为手机的表现比较诡异：提示复制成功但此时剪贴板却是空的或者还是上一次手动复制的内容，很明显它根本没有执行复制命令，但却告诉我复制成功了。换用官方给的代码 demo 以及自己用原生 execCommand 实现的代码表现都雷同。</p>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然知道原因，问题就好解决了，我采用的办法是新增一个标志位，然后监听目标元素的 copy 事件，只有当 copy 事件真实触发时才改变标志位状态，然后通过判断标志位来决定往后的逻辑，就酱~！</p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最近几天的博客变化]]></title>
      <url>http://shijianwen.github.io/2017/03/22/%E6%9C%80%E8%BF%91%E5%87%A0%E5%A4%A9%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%8F%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><img src="http://7xiuuj.com1.z0.glb.clouddn.com/wallhaven-317195.jpg" alt=""></p>
<blockquote>
<p>使劲折腾哎~</p>
</blockquote>
<p>一直都很想在博客里折腾点别的东西，像相册啊代码实验室啊什么的，但我又一直认为博客就是写文字的地方，不该跟其他那些功能混在一起，所以败了一个 VPS 和域名，起了一个 WordPress 小站 <a href="http://shijianwen.com" target="_blank" rel="noopener">http://shijianwen.com</a>，当做个人主站，里面放各种自己想玩的东西，博客还是这个博客，会在主站里面通过链接的形式引导过来，博客的域名也聚合在主站的域名下 <a href="http://blog.shijianwen.com" target="_blank" rel="noopener">http://blog.shijianwen.com</a>，之前那个 <a href="http://shijianwen.cn" target="_blank" rel="noopener">shijianwen.cn</a> 照旧用。</p>
<p>折腾 VPS 之外，还给博客换了个主题，之前那个太多人用了。。。一种人人都是你友站的感觉。。。</p>
<p>感觉像做了一次大扫除~</p>
]]></content>
      
        <categories>
            
            <category> 博客日志 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[【译】使用箭头函数精简你的 Vue 模块]]></title>
      <url>http://shijianwen.github.io/2016/12/05/arrow-function/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://dotdev.co/clean-up-your-vue-modules-with-es6-arrow-functions-2ef65e348d41#.vkndfgci3" target="_blank" rel="noopener">https://dotdev.co/clean-up-your-vue-modules-with-es6-arrow-functions-2ef65e348d41#.vkndfgci3</a><br>众成翻译地址：<a href="http://www.zcfy.cc/article/clean-up-your-vue-modules-with-es6-arrow-functions-dotdev-1872.html" target="_blank" rel="noopener">http://www.zcfy.cc/article/clean-up-your-vue-modules-with-es6-arrow-functions-dotdev-1872.html</a></p>
</blockquote>
<p>最近在重构一个用 Vue1.0 写的项目，我通过使用 ES6 的箭头函数来让代码在不升级 Vue2.0 的情况下变得更加简洁和统一。在这个过程中我也遇到了很多坑，所以想借此机会分享一下我从中学到的东西以及总结出来的一些规范，这些规范以后都将会落实到我的 Vue 项目中。</p>
<a id="more"></a>
<p>我们最好还是通过代码示例来讲解，下面给出一段代码，我们一步一步来分析它</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// require vue-resource...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">      item: &#123;</span><br><span class="line">        title: <span class="string">''</span>,</span><br><span class="line">        description: <span class="string">''</span>,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    saveItem: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.$http.post(<span class="string">'item'</span>, <span class="keyword">this</span>.item)</span><br><span class="line">        .then(</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            vm.item.title = <span class="string">''</span>;</span><br><span class="line">            vm.item.description = <span class="string">''</span>;</span><br><span class="line">          &#125;, </span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>, response);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面给出的这段代码实现了一个表单提交逻辑，用户提交表单之后发送请求在数据库新建一个数据项。但即使是这么简单的逻辑，其中也还有很多可以优化的地方。</p>
<hr>
<h3 id="箭头函数和-this-关键字"><a href="#箭头函数和-this-关键字" class="headerlink" title="箭头函数和 this 关键字"></a>箭头函数和 this 关键字</h3><p>先来看一下代码中的 <code>saveItem</code> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">saveItem: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$http.post(<span class="string">'item'</span>, <span class="keyword">this</span>.item)</span><br><span class="line">  .then(</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      vm.item.title = <span class="string">''</span>;</span><br><span class="line">      vm.item.description = <span class="string">''</span>;</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error'</span>, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开发中我经常很不爽的就是总是要把 <code>this</code> 关键字存起来，像上面的 <code>vm = this</code> 这个变量定义就是为了待会我们能够不受函数执行上下文影响地获取到 Vue 实例对象。假如有一种方法能够让我们彻底摆脱这种声明并且函数能够自动继承 this 关键字，岂不美哉？幸运的是，现在我们完全可以实现这个想法，因为有<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>。</p>
<p>在使用箭头函数的时候，<code>this</code> 是一个常量，这意味着现在的 this 不再动态指向当前的执行上下文了，而是继承了外围作用域。这意味着我们可以把上面代码中的 promise 回调函数用一种更加简洁的方法来重写并且不需要用临时变量来存储 this 就能取到 Vue 实例对象：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">saveItem</span>: function() &#123;</span><br><span class="line"></span><br><span class="line">  // let vm = this;</span><br><span class="line"></span><br><span class="line">  this.$http.post('item', this.item)</span><br><span class="line">   .then(</span><br><span class="line"></span><br><span class="line">    //function (response) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">     this.item.title = '';</span><br><span class="line">     this.item.description = '';</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    //function (response) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">     console.log('error', response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看起来很不错吧！</p>
<hr>
<h3 id="滥用箭头函数"><a href="#滥用箭头函数" class="headerlink" title="滥用箭头函数"></a>滥用箭头函数</h3><p>使用箭头函数的确很酷，但是不是每个地方用它都这么好呢？有些人可能不喜欢每次都声明一个 <code>function() {}</code> 所以把它们都用箭头函数的 <code>() =&gt; {}</code> 来简写。所以刚刚的 <code>saveItem()</code> 方法还可以改写成这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">methods</span>: &#123;</span><br><span class="line">  <span class="attribute">saveItem</span>: () =&gt; &#123;</span><br><span class="line">    this.$http.<span class="built_in">post</span>(<span class="string">'item'</span>, this.item)</span><br><span class="line">      .<span class="built_in">then</span>(</span><br><span class="line">        // callbacks in here</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会觉得这样改写后简直完美，整个代码都变得特别简洁，但是这样你将会踩到一个坑。</p>
<p>现在 <code>saveItem()</code> 方法里面的 <code>this</code> 指向的是 <code>window</code> 而不是我们希望的 Vue 实例对象（因为是继承外围作用域的this），当我们想要在给函数传递 <code>this.item</code> 整个参数的时候，你会发现它获取的是 <code>window.item</code>。</p>
<hr>
<h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" target="_blank" rel="noopener">ES6</a> 约定了一种新的函数定义方式，可以直接把函数名当成函数的声明，像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with ES6 method definitions, this becomes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo() &#123;&#125;,</span><br><span class="line">  bar() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以用这种方法来简写我们的 <code>saveItem()</code> 方法，同时也不会出现刚刚箭头函数带来的 this 继承的问题。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">  saveItem() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.post(<span class="string">'item'</span>, <span class="keyword">this</span>.item)</span><br><span class="line">      .then(</span><br><span class="line">        <span class="comment">// callbacks in here</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如果你觉得还不够简洁的话，可以按照这个方法改写所有 Vue 实例对象里面的顶级方法（<code>data</code> 和 <code>created</code> 这些）</p>
<hr>
<h3 id="data-相关"><a href="#data-相关" class="headerlink" title="data 相关"></a>data 相关</h3><p>在我们的代码里，我们的 <code>data</code> 是一个对象字面量。如果你熟悉 Vue 的话你会发现我们在真正开发的时候会把 <code>data</code> 这个对象当做闭包 return 回来。官方文档和<a href="http://codebyjeff.com/blog/2016/11/vue-js-simple-tuts-component" target="_blank" rel="noopener">这篇博客</a>有解释为什么这样做（译者注：这里要返回闭包是为了保证组件内部的状态独立，避免多个相同组件共用一个 data）。</p>
<p>我们刚刚了解到了很多优化的点，还知道了箭头函数里面的 this 是一个常量，它继承自外围作用域，除此之外，箭头函数还有一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">函数体定义</a>的新特性，前面的例子中我们定义函数体的时候用的是传统的块级结构方法（花括号包裹），箭头函数中我们可以使用一种更加简洁的代码结构来定义函数体，看下面的两段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;<span class="keyword">return</span> a+b;&#125;  <span class="comment">// 传统块级结构，必须要有 return</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;           <span class="comment">// 简单结构，不用声明 return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">a,b</span>) =&gt;</span> (&#123;<span class="attr">sum</span>: a+b&#125;);  <span class="comment">// 如果要返回一个对象字面量，则必须用括号包裹</span></span><br></pre></td></tr></table></figure>
<p>当你的函数只返回一个值的时候，可以直接把值写上，不再需要以往的花括号和 <code>return</code> 了，但如果需要返回一个对象字面量的话，就必须把你要返回的对象用括号包裹起来（译者注：花括号是运算符，声明这是一个计算值，否则会把对象字面量的花括号认为是箭头函数的函数体声明）。</p>
<p>我很喜欢这个小改动，另外你也可以使用 ES6 的函数定义方法来写</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method definition style</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="built_in">data</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    item: &#123;</span><br><span class="line">      title: <span class="string">''</span>,</span><br><span class="line">      description: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Vue-ES6-规范"><a href="#Vue-ES6-规范" class="headerlink" title="Vue ES6 规范"></a>Vue ES6 规范</h3><p>踩过那么多坑之后，我总结出了以下几条 Vue 模块定义规范：</p>
<ol>
<li><p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" target="_blank" rel="noopener">ES6 方法定义规范</a>来定义所有顶层方法</p>
</li>
<li><p>使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>定义所有在顶层方法里面的回调函数</p>
</li>
<li><p>使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Function_body" target="_blank" rel="noopener">“简单结构”</a>来定义 <code>data</code> 的函数体</p>
</li>
</ol>
<p>希望这些规范能够让你的 Vue 模块代码和组件更加吸引人并且更加可读，Thx！</p>
<hr>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p><a href="https://rainsoft.io/when-not-to-use-arrow-functions-in-javascript/" target="_blank" rel="noopener">https://rainsoft.io/when-not-to-use-arrow-functions-in-javascript/</a></p>
<hr>
<p><em>Originally published at</em> <a href="https://gist.github.com/JacobBennett/7b32b4914311c0ac0f28a1fdc411b9a7" target="_blank" rel="noopener"><em>gist.github.com</em></a>_._</p>
]]></content>
      
        <categories>
            
            <category> 外文翻译 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo 博客利用 github 分支同步源文件]]></title>
      <url>http://shijianwen.github.io/2016/12/01/hexo-sync/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;hexo 是一个优秀的静态博客工具，唯一的不足就是源文件无法同步，让人几乎只能在一台电脑上写博客，为了解决这个问题，我们可以使用 Github 来管理我们的 hexo 源文件，具体思路就是：在我们博客的远程仓库中新建一个分支，用这个分支来存储博客的源文件，这样我们每次在更新博客并部署之后可以顺手多执行两条命令将源文件同步到远程分支中去，不需要做任何环境切换的操作，还可以将部署和同步操作写成一个命令脚本，自动执行以上命令。建立同步的过程很简单：</p>
<a id="more"></a>
<h4 id="初始化版本库-amp-建立仓库关联（已与远程仓库关联的可忽略这一步）"><a href="#初始化版本库-amp-建立仓库关联（已与远程仓库关联的可忽略这一步）" class="headerlink" title="初始化版本库&amp;建立仓库关联（已与远程仓库关联的可忽略这一步）"></a>初始化版本库&amp;建立仓库关联（已与远程仓库关联的可忽略这一步）</h4><p>&emsp;&emsp;一般根据 hexo 教程一步步建立起来的博客都没有跟自己的远程仓库建立关联，查看是否关联的方法是输入 <code>git remote</code> 看是否有关联的远程仓库：<br><img src="/images/1480585048966.png" alt="Alt text"><br>可以看到我这里有一个名叫 origin 的仓库与我本地的文件夹关联，如果当前还没有关联，先用 <code>git init</code> 命令将你的本地文件夹初始化成一个版本库，然后使用 <code>git remote add origin 你的github仓库地址</code> 命令来建立与远程仓库的关联，这里的 origin 是你定义的远程仓库在本地的名字，你也可以叫别的，一般命名成 origin，这样就建立好了关联了，使用刚刚的 <code>git remote</code> 命令检测会看到你关联的仓库。</p>
<h4 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h4><p>&emsp;&emsp;像正常提交文件那样使用 <code>git add</code> 、 <code>git commit</code>  和 <code>git push</code> 命令提交文件，但这里在 push 的时候要注意新建一个分支去存你要提交的源文件，具体命令是 <code>git push -u origin HEAD:分支名</code>，这里的分支名自己取，HEAD 是版本库的头指针的意思，代表本地版本库里面的最新版本，origin 是刚刚你自己添加远程关联时候的名字，如果你的不是叫 origin 就写成自己定义的名字， -u 参数是为了建立本地分支与远程分支的关联，以后 push 的时候直接输入 <code>git push</code> 就可以了，所以这整个命令的意思就是：<code>把本地最新版本的代码提交到远程仓库的某个分支上去，如果远程仓库还没有这个分支，就在远程仓库里新建一个分支，然后将它跟本地当前分支关联起来</code>。提交之后你就会发现自己的 github 仓库多了一条分支，就是你刚刚提交的那个分支。<br>&emsp;&emsp;至于这里为什么不先在 github 上面手动建立分支，然后再在本地建立关联，是因为如果是远程手动建立分支会自动以 master 分支为模板建立一份一模一样的文件，而我们仓库里面 master 分支存的都是经过 hexo 编译的文件，跟源文件完全不一样，新建这样一个分支之后还要手动把里面的文件删掉，另一个原因是如果在远程手动建分支，你在本地还得手动用 <code>git fetch origin</code> 拉取远程分支的更新，然后再手动建立与分支的关联，比较麻烦，当然如果你是刚开始部署 hexo，github 仓库里面还一点东西都没有的话这些问题都不存在，那就随意。</p>
<h4 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h4><p>&emsp;&emsp;最后我们需要把你新建的那个分支设置成 github 的默认分支，这样做的原因是为了你以后在别的机器上拉取代码的时候能够直接拉取源文件，不用再指定分支。<br><img src="/images/1480586433661.png" alt="Alt text"><br>在这里选择好默认分支之后，update就行了。现在你就可以使用 github 来同步自己的 hexo 博客源文件啦~</p>
]]></content>
      
        <categories>
            
            <category> 博客日志 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 浏览器文本垂直居中问题]]></title>
      <url>http://shijianwen.github.io/2016/11/29/android-vertical-align/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在开发中，我们常使用 line-height 属性来实现文本的垂直居中，但是在安卓浏览器渲染中有一个常见的问题，就是对于小于12px的字体使用 line-height 属性进行垂直居中的时候，渲染出来的效果并不是文字垂直居中，而是会偏上一些。举两个代码示例如下：</p>
<p><strong><em> 1. 大于12px </em></strong></p>
<p>html<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>testtesttest<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>显示效果</p>
<p><img src="/images/1480324637887.png" alt=""></p>
<p><strong><em> 2. 小于12px </em></strong></p>
<p>html<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>testtesttest<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显示效果</p>
<p><img src="/images/1480324744155.png" alt=""></p>
<p>可以看到当 font-size 小于 12px 的时候，利用 line-height 属性进行垂直居中布局明显是偏上的，这里为了避免由于 font-size 是奇数带来的偏差，特意把 font-size 都设置成了偶数</p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>起初对这个问题有过两种推测，一是认为是字体的问题，或者是浏览器渲染的问题。但后面发现即使换了字体只要 font-size 还是小于 12px 一样会出现这个问题。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>看起来问题的根源在于字体大小小于 12px，所以解决问题可以从这个方向入手，要么改变字体大小，要么换个方式让它垂直居中。</p>
<p><strong><em> 1. 改变字体大小 </em></strong><br>最直接的方法就是改变字体大小让它大于 12px 能够正常居中，如果页面对字体大小要求比较严格的话，可以先将原来包括 font-size 在内的属性放大两倍，再用 scale 缩小一倍，这样测试之后也是可行的：</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>testtesttesttesttest<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(0.5);</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">0%</span> <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/1480389681672.png" alt=""></p>
<p>但不知道为什么，用这种方法之后我总是感觉文字没有绝对地居中，好像是有一点细微的偏下，不知道什么原因，不是 line-height 就是我的眼睛有问题。。。</p>
<p><strong><em> 2. table布局 </em></strong><br>在元素外再包一层，使用表格布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>testtesttesttesttest<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/1480400251642.png" alt=""></p>
<p>利用 table 布局能够比较好地实现文本垂直居中，缺点是要在外面多包一层容器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在查阅了很多资料之后，虽然能够解决这个问题，但导致问题的具体原因还是不够明显，只知道是安卓端浏览器的渲染问题，再往深一点的原因就有点鞭长莫及了，若有同行研究过这个问题，还望不吝赐教哈~</p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js 启动服务报 getaddrinfo ENOTFOUND]]></title>
      <url>http://shijianwen.github.io/2016/11/21/node-getaddrinfo-error/</url>
      <content type="html"><![CDATA[<p>在启动 node 服务后一直报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events.js:72</span><br><span class="line">    throw er; // Unhandled <span class="string">'error'</span> event</span><br><span class="line">          ^</span><br><span class="line">Error: getaddrinfo ENOTFOUND</span><br><span class="line">    at errnoException (dns.js:37:11)</span><br><span class="line">    at Object.onanswer [as oncomplete] (dns.js:124:16)</span><br></pre></td></tr></table></figure>
<p>造成这个错误的原因是本地的代理软件修改了host，让系统在 dns 解析的时候找不到 <code>localhost</code> 的地址，解决办法就是重新给系统加上host如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> node.js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo 博客 next 主题 js 加载 404 问题]]></title>
      <url>http://shijianwen.github.io/2016/11/21/assets-404/</url>
      <content type="html"><![CDATA[<p>这几天想要更新博客，打开之后发现所有 js 都加载失败了，查阅之后发现是近期 github page 升级造成了，自动屏蔽了 vendors 文件夹，next 原作者回复：<br><img src="/images/1479660158479.png" alt="Alt text"></p>
<p>问题有两个解决办法，一个是升级 next 的版本，但是新版本的一些配置可能不兼容了，所以谨慎升级，另一个方法是将 next 主题文件夹下的 <code>source/vendors</code> 文件夹重命名，然后将所有引用到了 vendors 的地方也一并重命名。</p>
]]></content>
      
        <categories>
            
            <category> 博客日志 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈 React、Flux 与 Redux]]></title>
      <url>http://shijianwen.github.io/2016/06/30/react-flux-redux/</url>
      <content type="html"><![CDATA[<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React 是一个 View 层的框架，用来渲染视图，它主要做几件事情：</p>
<ul>
<li>组件化</li>
<li>利用 props 形成单向的数据流</li>
<li>根据 state 的变化来更新 view</li>
<li>利用虚拟 DOM 来提升渲染性能</li>
</ul>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FgHh-hjZfigrSqf_9MZhjgmknC5N" alt=""></p>
<a id="more"></a>
<p>前面说到 React 能够根据 state 的变化来更新 view，一般来说引起 state 变化的动作除了来自外部（如服务器），大部分都来自于页面上的用户活动，那页面上的用户活动怎样对 state 产生作用呢？React 中每个组件都有 setState 方法用于改变组件当前的 state，所以可以把更改 state 的逻辑写在各自的组件里，但这样做的问题在于，当项目逻辑变得越来越复杂的时候，将很难理清 state 跟 view 之间的对应关系（一个 state 的变化可能引起多个 view 的变化，一个 view 上面触发的事件可能引起多个 state 的改变）。我们需要对所有引起 state 变化的情况进行统一管理，于是就有了 Flux。 </p>
<h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>Flux 是一种应用架构，或者说是一种思想，它跟 React 本身没什么关系，它可以用在 React 上，也可以用在别的框架上。前面说到 Flux 在 React 中主要用来统一管理引起 state 变化的情况。Flux 维护着一个或者多个叫做 <code>Store</code> 的变量，就像 MVC 里面的 Model，里面存放着应用用到的所有数据，当一个事件触发时 ，Flux 对事件进行处理，对 Store 进行更新，当 Store 发生变化时，通常是由应用的根组件（也叫 controller view）去获取最新的 store，然后更新 state，之后利用 React 单向数据流的特点一层层将新的 state 向下传递实现 view 的更新。这里的 controller view 可以有多个也可以不是根组件，但是这样数据流维护起来就比较麻烦。</p>
<p>Flux 的思维模型如下：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FonZpI0A0bUAcv1jwAhJdALdqDOj" alt=""></p>
<p>Flux 主要包括四个部分，<code>Dispatcher</code>、<code>Store</code>、<code>View</code>、<code>Action</code>，其中 Dispatcher 是 Flux 的核心枢纽，它相当于是一个事件分发器，将那些分散在各个组件里面的逻辑代码收集起来，统一在 Dispatcher 中进行处理。完整的 Flux 处理流程是这样的：用户通过与 view 交互或者外部产生一个 Action，Dispatcher 接收到 Action 并执行那些已经注册的回调，向所有 Store 分发 Action。通过注册的回调，Store 响应那些与他们所保存的状态有关的 Action。然后 Store 会触发一个 change 事件，来提醒 controller-views 数据已经发生了改变。Controller-views 监听这些事件并重新从 Store 中获取数据。这些 controller-views 调用他们自己的 setState() 方法，重新渲染自身以及组件树上的所有后代组件。使用 Flux 有个好处就是我只需要用 action 对象向 Dispatcher 描述当前的事件就可以执行对应的逻辑，因为 Dispatcher 是所有 Action 的处理中心，即使没有对应的事件发生，我们也可以“伪造”一个出来，非常利于测试。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux 的作用跟 Flux 是一样的，它可以看作是 Flux 的一种实现，但是又有点不同，具体的不同总结起来就是：</p>
<p><strong><em> 1. Redux 只有一个 store </em></strong></p>
<p>Flux 里面会有多个 store 存储应用数据，并在 store 里面执行更新逻辑，当 store 变化的时候再通知 controller-view 更新自己的数据，Redux 将各个 store 整合成一个完整的 store，并且可以根据这个 store 推导出应用完整的 state。同时 Redux 中更新的逻辑也不在 store 中执行而是放在 reducer 中。</p>
<p><strong><em> 2. 没有 Dispatcher </em></strong></p>
<p>Redux 中没有 Dispatcher 的概念，它使用 reducer 来进行事件的处理，reducer 是一个纯函数，这个函数被表述为 <code>(previousState, action) =&gt; newState</code>，它根据应用的状态和当前的 action 推导出新的 state。Redux 中有多个 reducer，每个 reducer 负责维护应用整体 state 树中的某一部分，多个 reducer 可以通过 <code>combineReducers</code> 方法合成一个根reducer，这个根reducer负责维护完整的 state，当一个 action 被发出，store 会调用 dispatch 方法向某个特定的 reducer 传递该 action，reducer 收到 action 之后执行对应的更新逻辑然后返回一个新的 state，state 的更新最终会传递到根reducer处，返回一个全新的完整的 state，然后传递给 view。</p>
<p>在我看来，Redux 和 Flux 之间最大的区别就是对 store/reducer 的抽象，Flux 中 store 是各自为战的，每个 store 只对对应的 controller-view 负责，每次更新都只通知对应的 controller-view；而 Redux 中各子 reducer 都是由根reducer统一管理的，每个子reducer的变化都要经过根reducer的整合。用图表示的话可以像这样：</p>
<p>Flux 中的 store 是这样的：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FulidOFq7yfm-fyPHy9qm50JDu-K" alt=""></p>
<p>Redux 中的 store（或者叫 reducer）是这样的：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FqwrgoH93cl8a5f3oFc0XZL7waBQ" alt=""></p>
<p>ps：刚接触 React，很多地方了解地不是特别深入，如有错漏，欢迎指正。</p>
]]></content>
      
        <categories>
            
            <category> ReactJS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[许愿墙总结文档]]></title>
      <url>http://shijianwen.github.io/2016/03/01/%E8%AE%B8%E6%84%BF%E5%A2%99%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h3><p><strong><em>Angular</em></strong><br>优点：声明式 UI、完善的指令系统、双向数据绑定、模块化、依赖注入、完整的 MVC 以及可以自定义的指令<br>缺点：自带的路由模块功能比较弱，需要依靠第三方的 uiRouter，整体较笨重，不适合做交互频繁的网页，对于一个页面显示数据量较大的网页性能优化是一个问题，还有就是对 SEO 不友好。<br><a id="more"></a></p>
<h3 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h3><p><strong><em>Node.js</em></strong><br>优点：事件驱动以及非阻塞的异步 IO 使它能够很好地应对高并发场景，适合做 IO 密集型的应用<br>缺点：JS 的单线程限制使其很难利用服务器的多核资源，可靠性较低，一旦挂了就整个服务都崩溃了</p>
<h3 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h3><p><strong><em>MongoDB</em></strong><br>优点：文档结构的存储方式，能够更好地管理数据，查询速度也更快，也能够减少磁盘 IO；JSON 风格的语法易于理解和掌握<br>缺点：不支持事务操作，占用空间较大（为避免产生磁盘碎片），删除记录后并不释放空间（为了避免大规模的数据移动）</p>
<h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><p>静态资源存储使用<strong><em>七牛云存储</em></strong><br>实时消息的推送和实时消息传递使用 <strong><em>socket.io</em></strong><br>后端使用 <strong><em>Express</em></strong> 框架<br>开发环境配置使用 <strong><em>Gulp</em></strong><br>部署环境使用 <strong><em>BAE</em></strong></p>
<h2 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h2><h3 id="1-如何把图片上传到七牛的过程跟微信-SDK-中的上传图片过程连接起来"><a href="#1-如何把图片上传到七牛的过程跟微信-SDK-中的上传图片过程连接起来" class="headerlink" title="1. 如何把图片上传到七牛的过程跟微信 SDK 中的上传图片过程连接起来"></a>1. 如何把图片上传到七牛的过程跟微信 SDK 中的上传图片过程连接起来</h3><p><strong><em>问题背景</em></strong><br>因为要把愿望的图片保存在七牛的服务器上，虽然七牛有自己的上传组件，但是那个上传组件点击后出现的是选择所有类型文件的界面，我希望上传图片的时候是那种选择相册或拍照的方式，也就是微信 SDK 提供的选择图片接口那样的功能，此时的难点在于怎样把通过微信 SDK 选择到的图片传给七牛。<br><strong><em>解决方案</em></strong><br>利用了微信 SDK 提供的上传图片接口和七牛的 fetch 接口，当微信选择了图片之后就把图片上传到微信服务器上，上传成功后会返回一个图片的下载链接，然后再用七牛的 fetch 接口向这个下载链接发送请求，获取到图片文件，然后存入七牛空间。</p>
<h3 id="2-微信无故循环报-access-token-40001-错误"><a href="#2-微信无故循环报-access-token-40001-错误" class="headerlink" title="2. 微信无故循环报 access_token 40001 错误"></a>2. 微信无故循环报 access_token 40001 错误</h3><p><strong><em>问题背景</em></strong><br>许愿墙最后一天的时候男女功能反转，会出现一波用户请求的高峰，在 access_token 过期后，有多个用户同时请求了新的 access_token，access_token 在传输回服务器的过程中由于网络原因导致 access_token 返回的先后顺序跟请求的先后顺序不同，造成服务器缓存的是一个微信服务器不承认的 access_token（因为新请求的 access_token 会把前面的 access_token 覆盖）。<br><strong><em>解决方案</em></strong><br>增加错误处理，出现问题后清空 access_token 的缓存，然后重新请求新的 access_token。</p>
<h3 id="3-BAE-多个执行单元导致-soket-io-报错"><a href="#3-BAE-多个执行单元导致-soket-io-报错" class="headerlink" title="3. BAE 多个执行单元导致 soket.io 报错"></a>3. BAE 多个执行单元导致 soket.io 报错</h3><p><strong><em>问题背景</em></strong><br>这个问题相当于开了多个 node 进程后 socket.io 的消息分配问题，由于有多条进程在运行后台，当有实时消息请求但此时通信双方请求的是不同进程的时候会导致 socket.io 报错。<br><strong><em>解决方案</em></strong><br>为了解决这个问题，我使用 redis 做了一个事件订阅/发布模型，多个服务器进程订阅发布进程，然后由发布进程统一处理所有的实时请求。</p>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ol>
<li>代码的优化不够，对 Angular 和 Node 掌握不够导致很多优化技巧没有用上；</li>
<li>前期的规划不足导致开发中经常要对之前的代码进行重构；</li>
<li>权限控制做得不好，没有花时间在这方面；</li>
<li>开发节奏不够好，难以掌控进度。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器事件模型]]></title>
      <url>http://shijianwen.github.io/2016/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>事件是 JavaScript 和 HTML 交互的基础，在 W3C 标准出来之前，各个浏览器都有自己的一套事件方法，有的使用事件捕获，有的使用事件冒泡，它们都支持直接在 HTML 元素上绑定事件，这个时候的事件模型被称为 0级DOM。W3C 标准统一之后，对浏览器的事件模型做了一定的前后兼容并新增了一些特性，这个时候的事件模型被称为 2级DOM（没有 1级DOM 是因为在 1级DOM 的标准里没有定义跟事件有关的内容）。<br><a id="more"></a></p>
<p>###事件捕获<br>简单来说，事件捕获就是假设父子元素都绑定了 click 事件，那么 click 事件触发的时候先在父元素出发，后在子元素触发。假设文档结构为 document–&gt;div–&gt;a，那么事件流触发的方向就是 document–&gt;div–&gt;a。古老的 netscape 浏览器用的就是这种事件模型。</p>
<p>###事件冒泡<br>事件冒泡和事件捕获正好相反，事件先在子元素触发，再在父元素触发，依旧假设文档结构为 document–&gt;div–&gt;a，事件流方向问 a–&gt;div–&gt;document。IE 浏览器使用的是这种事件模型。</p>
<p>###0级DOM<br>在 W3C 标准出来之前的浏览器事件模型被称为 0级DOM，一开始浏览器处理事件只有原始的事件模型，它把 js 代码作为 HTML 的事件属性值被插入 HTML 中比如 <code>&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;click!&#39;)&quot;&gt;click&lt;/button &gt;</code>，或者传入一个函数名称 <code>&lt;button id=&quot;btn&quot; onclick=&quot;doSomething&quot;&gt;click&lt;/button&gt;</code>，还可以在 js 中通过获取对应 HTML 元素的对象给它绑定事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"><span class="comment">//绑定事件监听函数</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 0级DOM 中，事件监听函数是作为元素的方法调用的，所以事件监听函数的 this 指向的是该元素本身，当在事件监听函数里面返回 false 值的话将会阻止该元素原本的默认事件触发，比如当在一个表单的提交按钮中绑定一个 return false 的函数，那么这个表单将不会被提交。另外在 0级DOM 中只能给元素绑定一个事件，如果绑定多个事件那么后面定义的事件将会覆盖前面定义的事件。</p>
<p>###2级DOM<br>W3C 标准出来之前各家浏览器都是百花齐放，按照自己的一套标准来搞，甚至会出现恶性竞争的情况比如 IE 和 netscape 的浏览器大战，同时这两个浏览器采用的也是两种背道而驰的事件模型。在标准出来之后，对事件模型约定了全新的标准，统称为 2级DOM，2级DOM 采用了事件捕获和事件冒泡组合的事件模型来确保浏览器之间的兼容，它把事件的触发分为三个阶段，第一个阶段是捕获阶段，事件流从 document 开始流向目标元素，第二个阶段是处理阶段，这个阶段发生在目标元素中，在这个阶段执行目标元素绑定的事件监听函数，第三个阶段是冒泡阶段,事件流从目标元素流向 document。在 2级DOM 中还新增加了 addEventListener 方法来给元素绑定事件，使用 addEventListener 方法绑定的事件可以在三个阶段中的任何一个阶段触发，addEventListener 接收三个参数，第一个是事件类型，第二个是事件监听函数，第三个是一个布尔值，用来决定事件在哪个阶段触发，true 表示在任意阶段都可以触发，false 表示在捕获阶段不能触发。使用 addEventListener 方法可以给同一个元素绑定多个事件，并不会出现 0级DOM 里那种函数覆盖的情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实例</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>###事件对象<br>在 0级DOM 和 2级DOM 定义的事件监听函数中都有一个默认参数，它是一个在函数触发时自带的事件对象，这个对象包含了事件触发的一些必要信息，比如事件触发的元素，当时鼠标所处的位置信息以及键盘按键信息等，有了事件对象，我们就可以解决一些常见的 DOM 操作问题，如果我有一个列表，初始有三个列表项，并且这个列表项是动态的，会根据用户的添加和删除操作增减列表项，我要给这个列表中的所有列表项都绑定一个点击事件，这个时候如果我们直接使用普通方法给列表项绑定事件的话那么在增加了新的列表项之后该新增项将不会被绑定事件，原因是 JavaScript 只执行一次，当你新增了列表项之后绑定点击事件的代码并不会重新运行一次。我们可以利用事件冒泡和事件对象来解决这个问题，当点击事件发生的时候，我们让事件往上冒泡，一直冒泡到 document 元素，然后事先在 document 元素上绑定点击事件，让 document 元素来统一处理所有的点击事件，但是光使用事件冒泡还不能够让我们新增的列表项绑定事件，这个时候就要用到事件对象了，事件对象 event 有一个属性 currentTarget，其值是当前事件正在处理的元素，我们可以利用这个来识别当前的元素是不是我们要触发点击事件的元素，如果是的话，就触发，如果不是，就不触发，这样问题就解决了，JQuery 的事件绑定函数 on 里面的实现原理大概也是这样的（当然没这么简单）。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[FEX 面试题解析（二）]]></title>
      <url>http://shijianwen.github.io/2016/01/24/FEX-two/</url>
      <content type="html"><![CDATA[<p><strong><em>1. What does a doctype do?（doctype 是什么）</em></strong><br>doctype 是指网页的文档类型，用来指定这个网页用什么版本的 HTML 或者 XHTML，如果不指定文档类型，代码里的标签和样式就没办法正确地解释出来。</p>
<p><strong><em>2. What’s the difference between standards mode and quirks mode?（标准模式和怪异模式有什么区别）</em></strong><br>标准模式和怪异模式（也称兼容模式）是浏览器的渲染网页的两种标准，W3C 标准普及之后，为了兼容那些年代久远的网页，就采用了两种模式渲染的方式来解决这个问题，一般通过识别网页的 doctype 声明来决定使用哪种模式渲染。这两种模式最大的区别在于对盒模型的定义上，在标准模式中，盒子的 width 等于盒子的内容区的宽度，在怪异模式中，盒子的 width 等于内容区宽度加上边界宽度、内边距和外边距的宽度。<br><a id="more"></a><br><strong><em>3. What’s the difference between HTML and XHTML?（HTML 和 XHTML 有什么区别）</em></strong><br>HTML 是基于 SGML 的一种应用，同样基于 SGML 的还有 XML，XML 主要用来携带和传递数据，HTML 主要用来表示数据，两者各有优势，为了能让 HTML 过渡到 XML 统一标准，出现了 XHTML。XHTML 能够兼容所有的 HTML 语法，但是在要求上更加严格，比如 XHTML 中所有的标签必须小写，所有标签必须闭合，每一个属性都必须使用引号包住。</p>
<p><strong><em>4. Are there any problems with serving pages as application/xhtml+xml?（使用 application/xhtml+xml 有什么问题）</em></strong><br>IE6，7，8不支持，IE6，7，8支持text/html。</p>
<p><strong><em>5. How do you serve a page with content in multiple languages?（如何实现一个多种语言版本的页面）</em></strong><br>一个可以用域名跳转，不同的语言版本跳转到不同的域名<br>另一个可以通过浏览器发送带 accept-language 头部信息的请求请求不同版本的页面文档<br>参考：<a href="http://www.pro-tekconsulting.com/blog/how-do-you-serve-a-page-with-content-in-multiple-languages/" target="_blank" rel="noopener">How do you serve a page with content in multiple languages?</a></p>
<p><strong><em>6. What are data- attributes good for?（data 属性有什么好处）</em></strong><br>data- 属性使 HTML 有了存储数据的能力，它让 HTML 更加灵活，JavaScript 可以通过 dataset 方法访问到 data-<em> 的自定义属性，CSS 中也可以通过 attr 方法来引用 data-</em> 属性的值。</p>
<p><strong><em>7. Describe the difference between a cookie, sessionStorage and localStorage.（cookie，sessionStorage，localStorage 之间的区别）</em></strong><br>1）. 大小<br>cookie 最多只有 4kb，而 sessionStorage 和 localStorage 大小一般可以有 5M<br>2）. 生命周期<br>cookie 的生命周期由服务器控制，默认是关闭浏览器后删除；sessionStorage 仅在当前的窗口有效，localStorage 除非手动删除否则一直存在。<br>3）. http 通信<br>浏览器每次向服务器发送请求的时候都要带上该域的 cookie，而 sessionStorage 和 localStorage 仅存在于浏览器端。<br>4）. 作用域<br>cookie 和 localStorage 在同个域名下的多个窗口都有效，sessionStorage 只在一个窗口有效，不能跨窗口共享。<br>5）. 易用性<br>sessionStorage 和 localStorage 属于 HTML5 的 Web Storage 的 API，更加灵活易用。</p>
<p><strong><em>8. Describe the difference between &lt; script &gt;, &lt; script async &gt; and &lt; script defer &gt;.（普通脚本加载方式和 async、defer 方式有什么区别）</em></strong><br>普通脚本加载方式在加载和执行时会阻塞页面的渲染，async 和 defer 方式是用异步的方式加载脚本，不会阻塞页面渲染，它们之间的不同在于何时执行，async 方式是加载后马上执行，defer 方式是加载后等所有 DOM 都渲染好触发 DOMContentLoaded 事件之前执行，所以 async 方式里面的脚本都是乱序执行，defer 方式加载的代码都是按序执行的，按序执行对有依赖的代码非常重要。</p>
<p><strong><em>9. Why is it generally a good idea to position CSS &lt; link &gt;s between &lt; head &gt;&lt; /head &gt; and JS &lt; script &gt;s just before &lt; /body &gt;? Do you know any exceptions?（为什么要建议把 css 放到 head 标签内 和 js 要放到 body 结束标签之前？有什么例外吗）</em></strong><br>把 css 放在 head 标签内是为了首先下载样式表然后进行渲染，这样能够避免页面由于没有样式造成的 FOUC，把 js 放到 body 结束标签之前是为了不让 js 的加载阻塞页面的渲染，而且一般情况下 js 会包含 DOM 操作，如果在还没有完全加载好 DOM 树的情况下就执行 js 很可能会报错。例外就是，当脚本使用 defer 方式加载的时候可以不用约束放置的位置。</p>
<p><strong><em>10. What is progressive rendering?（什么是渐进式渲染）</em></strong><br>渐进式渲染是指浏览器不用等待所有页面资源都渲染好之后再呈现给用户看，而是边下载边渲染，所以用户打开一个网页的时候往往不能第一时间看到所有的内容，但是能够看到一个大概的样子，后续的内容浏览器会慢慢补上形成一个完整的页面。这个有点像 bigpipe。</p>
]]></content>
      
        <categories>
            
            <category> 待业青年 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[FEX 面试题解析（一）]]></title>
      <url>http://shijianwen.github.io/2016/01/14/FEX-one/</url>
      <content type="html"><![CDATA[<p>前言：这学期大三了，马上就到了找实习的日子，感谢百度 FEX 开源了一个面试题目库<a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/blob/master/README.md#fun-questions" target="_blank" rel="noopener">Front-end Job Interview Questions</a>，让我能够审查一遍自己的知识疏漏，这个系列的博文将会根据题库里面的非主观题目做一些力所能及的解释。</p>
<p> <strong><em>1. Can you describe the difference between progressive enhancement and graceful degradation?（描述一下渐进增强和优雅降级的不同）</em></strong><br>渐进增强和优雅降级是对待同种事物的两种不同看法，举例来说，渐进增强就是做网站的时候先做一个基础的完整功能，然后针对一些先进的浏览器做一些更加先进的匹配以提升用户体验；优雅降级就是做网站的时候先按照先进浏览器的高标准做，然后再针对一些比较落后的浏览器做一些匹配使它们不会完全无法使用。<br><a id="more"></a></p>
<p><strong><em>2. How many resources will a browser download from a given domain at a time?（浏览器能够同时从一个域名下下载多少个资源）</em></strong><br>Chrome、Firefox、Safari 最新版本都支持同时下载 6 个资源，IE11 支持同时 8 个资源。<br>详见 <a href="http://stackoverflow.com/questions/985431/max-parallel-http-connections-in-a-browser/14768266#14768266" target="_blank" rel="noopener">StackOverFlow</a></p>
<p><strong><em>What are the exceptions?（有什么解决办法）</em></strong><br>因为浏览器的并发连接数限制是针对同一个域名的，所以可以使用多个域名指向同一个 ip 地址的方式来解决浏览器并发连接数的问题，多域名通常用来储存网站需要用到的静态资源，把静态资源从主域名移出到专门的静态资源服务器的好处之一是解决并发连接数的限制，另一个好处是如果静态资源放在主域名下，在请求这些资源的时候浏览器会发送本地存储好的对应主域名的 cookie 信息，这些 cookie 在请求这些静态资源的时候是不需要的，这是一种性能的浪费，使用多域名可以解决这个问题。但是多域名随之而来还有一个缺点就是增加了 DNS 查询的时间。</p>
<p><strong><em>3. What is Flash of Unstyled Content? How do you avoid FOUC?（什么是浏览器无样式闪烁，怎样避免）</em></strong><br>FOUC 是指当样式表迟于 HTML DOM 结构加载的时候，浏览器出现的短暂的没有样式的屏幕闪烁现象，这是因为当加载到这个迟来的样式表并解析的时候，浏览器会停止之前的渲染转而重新去渲染现在的这个样式表，这样就造成了短暂的花屏现象。这种现象的成因有两个：一个是使用了 import 加载样式表，一个是把样式表放在了页面底部加载。解决办法就是避免使用 import 并且把样式放在 head 标签内部加载。</p>
<p><strong><em>4. Explain some of the pros and cons for CSS animations versus JavaScript animations.（CSS 动画对比 JavaScript 动画有哪些有点和缺点）</em></strong><br>优点：浏览器对 CSS 有优化、GPU 加速（这个 JS 也能做到）、代码简单；<br>缺点：不灵活，无法控制很细粒度的动画效果、兼容性。</p>
<p><strong><em>5. What does CORS stand for and what issue does it address?（CORS 是什么意思）</em></strong><br>CORS（跨域资源共享）是指服务器允许不同域名下的请求发过来进行处理，因为浏览器有跨域限制，为了安全起见只允许将请求发送到相同域名下的服务器进行处理，CORS 可以通过设置服务器响应头部信息接收来自指定域的请求。</p>
]]></content>
      
        <categories>
            
            <category> 待业青年 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[BAE 多个执行单元使用 socket.io]]></title>
      <url>http://shijianwen.github.io/2015/12/25/BAE-socketio/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在许愿墙开放前夕，我任性地将原来百度云擎四毛钱的套餐升级成了三块钱的套餐，升级的主要动作就是增加执行单元的数量，升级之后出现了一个问题就是 socket.io 有时候不管用了，在许愿墙里 socket.io 我是用来做实时的消息推送和用户之间的实时私信功能的，升级之后出错的具体问题就是有时候跟用户发私信的时候对方并不能实时接收，只能等到下次登录的时候去数据库拿未读消息的时候才能看到。本地调试的时候发现 socket.io 抛出的错误信息是 <code>socket.io connection closed before receiving a handshake response</code> 。几番查询之后发现是由于服务端开了多条进程而进程之间无法通信导致的。这时候我就明白了原来百度云擎增加执行单元的数量就相当于多开了一条独立的进程跑你的后台，从而提高整个服务的性能和负载能力，难怪这么贵。。。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了解决多进程之间通信的问题，我决定使用 redis 服务器做成一个事件订阅和发布的模型，在网上搜索找到了一篇类似的文章：<a href="http://godbae.duapp.com/?p=1096" target="_blank" rel="noopener">《利用扩展服务实现基于websocket的聊天室》</a>，不同的是那篇文章使用的是 nodejs-websocket 这个库，我在许愿墙里使用的是 socket.io，两种不同的库做起来方法有所不同，所以这里我打算总结一下在使用 socket.io 的时候如何利用 redis 做一个进程间的消息发布与订阅模块。</p>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;首先就是开通 BAE 的 port 服务和 redis 服务了，这里不赘述，参考上面那篇文章就行，另外最好也像文章里那样开一个 log 服务，因为多个执行单元的运行的时候不同执行单元的日志会打印到不同的地方，因此我们需要 log 服务来统一管理这些日志方便我们 debug。<br>&nbsp;&nbsp;&nbsp;&nbsp;当你把服务都开通并且能够跑的时候，需要在 server.js 里面加入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>).listen(xxx);</span><br><span class="line"><span class="keyword">var</span> channel = ak; <span class="comment">//channel 就是你待会发布和订阅的频道，这里给它随便取一个名字</span></span><br><span class="line"><span class="keyword">var</span> db = <span class="string">'&#123;db&#125;'</span>;  <span class="comment">//这个 db 是你的 redis 数据库的名字</span></span><br><span class="line"><span class="keyword">var</span> auth = ak + <span class="string">"-"</span> + sk + <span class="string">"-"</span> + db; <span class="comment">//ak，sk 分别是数据库的 access_token 和 secret_token，在 BAE 后台可查</span></span><br><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">"redis"</span>); </span><br><span class="line"><span class="comment">//创建两个 redis 客户端，subClient 是订阅了某个频道的客户端，pubClient 负责在某个频道发布消息的客户端</span></span><br><span class="line"><span class="keyword">var</span> subClient = redis.createClient(<span class="number">80</span>, <span class="string">"redis.duapp.com"</span>, &#123;<span class="string">"no_ready_check"</span>: <span class="literal">true</span>&#125;); </span><br><span class="line"><span class="keyword">var</span> pubClient = redis.createClient(<span class="number">80</span>, <span class="string">"redis.duapp.com"</span>, &#123;<span class="string">"no_ready_check"</span>: <span class="literal">true</span>&#125;); </span><br><span class="line">subClient.auth(auth); </span><br><span class="line">pubClient.auth(auth); </span><br><span class="line">subClient.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">channel, message</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 当收到redis的订阅通知时，将消息发送给所有的 websocket 连接 </span></span><br><span class="line">    io.sockets.emit(message);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//让 subClient 订阅 channel 这个频道</span></span><br><span class="line">subClient.subscribe(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来的就跟普通的 socket.io 那样用了</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[微信 access_token 报 40001 invalid token 的一个隐藏原因]]></title>
      <url>http://shijianwen.github.io/2015/12/07/wechat-access-token-error/</url>
      <content type="html"><![CDATA[<p>在许愿墙最后一天的男生许愿环节中，由于男生数量众多（逃），在一段时间后导致七牛存储的图片挂了，经过查询之后确定是由于获取到的微信 access_token 不正确造成的，报 40001 invalid token 错，因为我的 access_token 是全局缓存在服务器中的，有效期为两个小时，当时我采取的做法是暂时取消全局缓存的策略，采用每次请求一个新 token 的方法来暂时替代，因为考虑到许愿墙的用户数量少而且只是发图片的时候才需要使用到 token，所以即使 token 的获取次数有限制也不会有超出限制的风险。临时修复之后我上网查询后发现，这是一个比较隐藏的原因的造成的：当用户请求比较多的时候，在 token 过期的时候有多个用户同时请求了 token，但是由于网速的问题，导致了一些卡顿，比如 A B 同时请求了新的 token，A 先请求到了 token C，B 后请求到了 token D，此时微信服务器默认正确的 token 应该是 token D，因为多次重复的刷新 token 会使新请求到的 token 覆盖掉前面请求的 token，但是由于返回的时候网络卡顿的原因，本来应该 token C 先返回，token D 后返回的，由于卡顿导致 token D 先返回了，返回之后被存在缓存里，但随后 token C 紧随其后也来到了服务器，这时候 token C 也被写入了缓存覆盖掉了 token D，这时候错误就产生了，服务器缓存里此时存着的是不被微信服务器承认的 token，所以使用这个缓存的 token 去做任何操作都会导致 token 错误被抛出，我在许愿墙遇到的问题也是由此产生的，解决办法就是清除此时的缓存，让服务器去请求全新的有效的 token 重新缓存，我上面的做法并不值得提倡，因为我是基于用户数少考虑并且当时还不清楚具体出错原因考虑的。推荐的方法还是手动清除缓存。</p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 AngularJS 应用中无法预览微信 SDK 选择的本地图片的解决办法]]></title>
      <url>http://shijianwen.github.io/2015/11/16/angular-wechat-sdk/</url>
      <content type="html"><![CDATA[<p>通过微信 SDK 选择了本地图片后，在 AngularJS 应用中无法通过把 localId 赋值给 img 的 ng-src 属性进行预览，但是当直接赋值给 img 标签的 src 属性时却可以正常预览。出现这个问题是的原因是 AngularJS 自身的安全策略，为了避免别人通过图片 link 发起 XSS 攻击，凡是通过 ng-src 指令给元素赋值的在编译阶段都会进行 src 路径合法性的检查，并且由 Angular 维护着一份正则表达式形式的白名单，只有 src 符合白名单里的要求的才被允许赋值，否则都会使这个 src 无效并在前面加上一个 unsafe 标记。所以这个问题的解决办法就是修改本地的白名单，让微信的 localId 不被 Angular 当做不安全的 url，具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'myApp'</span>, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置图片白名单</span></span><br><span class="line">app.config([<span class="string">'$compileProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$compileProvider</span>) </span>&#123;</span><br><span class="line">    $compileProvider.imgSrcSanitizationWhitelist(<span class="regexp">/^\s*(https?|weixin|wxlocalresource):/</span>);</span><br><span class="line">    <span class="comment">//其中 weixin 是微信安卓版的 localId 的形式，wxlocalresource 是 iOS 版本的 localId 形式</span></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bug异闻录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么 DOM 这么慢？]]></title>
      <url>http://shijianwen.github.io/2015/11/16/why-dom-so-slow/</url>
      <content type="html"><![CDATA[<h3 id="一、DOM-的本质"><a href="#一、DOM-的本质" class="headerlink" title="一、DOM 的本质"></a>一、DOM 的本质</h3><p>在浏览器里， DOM 只是一些操作 HTML 或者 XML 元素的接口的集合，为了让别的语言也能通过这些接口来操作文档，浏览器的 DOM 部分和 ECMAScript 的部分是分开放的，也就是说，DOM 跟 ECMAScript 是独立的两个部分，要想操作 HTML，就得使用 DOM 提供的接口来连接 HTML 文档，所以每次使用 ECMAScript 进行 DOM 操作的时候都需要经过一个连接接口进行调用的过程，这个过程有着很大的性能损耗，操作 DOM 的次数越多，性能的影响就越大，从而表现出 DOM 操作特别慢的现象。</p>
<a id="more"></a>
<h3 id="二、重绘与重排"><a href="#二、重绘与重排" class="headerlink" title="二、重绘与重排"></a>二、重绘与重排</h3><p>当浏览器下载完页面后，便开始解析页面并生成两个内部数据结构：DOM 树和渲染树，DOM 树用来表示页面的结构，渲染树用来表示 DOM 节点如何显示，一旦这两个数据结构构建完成，浏览器就开始绘制页面元素。DOM 树里每一个节点在渲染树里都至少有一个节点与之对应（隐藏的节点在渲染树立没有对应的节点），在渲染树里，它把所有节点都看作是一个有内外边距和位置属性的盒子，当节点的几何属性（如宽高，位置）被更改之后，浏览器会重新计算这些更改的属性，然后使渲染树中对应的部分失效，并且重新构造渲染树，这个过程被称为“重排”。完成重排过程后，浏览器会重新绘制那些受影响的部分，这个过程称为“重绘”。有些 DOM 操作并不会导致重排，比如更改背景颜色，这种操作只会导致重绘。重排与重绘往往不是发生在单独一个元素上，在文档流里，一个元素的几何属性改变有可能会导致整个页面的重排或者重绘操作，比如在网页 body 最上方插入一个子元素，这时其后的所有被这个元素影响到的子元素都要跟着重新计算重新渲染。重排跟重绘都是代价昂贵的操作，这也是 DOM 表现出特别慢的一个重要原因。</p>
<h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>我们知道 DOM 速度特别慢这个事实后，在开发中我们就需要尽量地减少 DOM 操作，减少 DOM 操作的根本其实就是减少重绘或者重排的次数。当我们需要批量操作 DOM 的时候，可以先把目标节点隐藏起来然后进行操作，操作完成之后再把节点还原，也可以利用 document.createDocumentFragment 方法先生成一个完整的文档片段，完成之后再一次性插入 HTML 文档中，这样就避免了浏览器在每一次 DOM 操作后都进行一次重排和重绘操作。同样的，把目标节点脱离文档流也能达到类似的效果，有些时候一些网页特效并不允许我们把它隐藏起来执行，比如 js 动画，但是 js 动画确实一个及其耗费性能的事情，每一帧的变换都需要经过重排或者重绘操作，无形之中给网页带来了极大的性能开销。利用脱离文档流的方式可以使动画执行时只影响自身的重绘与重排，而不会影响其他元素，常见的脱离文档流方式就是绝对定位。利用绝对定位，使元素脱离文档流，等执行完动画之后再插入文档流，这时候进行的重排重绘操作只发生在执行动画的元素本身，从而提升了性能。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用微信 SDK 上传图片到七牛]]></title>
      <url>http://shijianwen.github.io/2015/11/05/wechat-sdk-upload-img/</url>
      <content type="html"><![CDATA[<p>总体思路是：在微信下选好图片后将图片上传到微信服务器，在后端使用微信服务器返回的图片 serverId 加上调用接口的 ApiTicket 通过七牛的 fetch 接口向微信服务器下载多媒体文件的接口请求图片的二进制流，然后保存至自己七牛账号内的特定 bucket。<br>大致过程如下：</p>
<a id="more"></a>
<h3 id="1-调用微信-chooseImage-接口，成功后调用-uploadImage-接口"><a href="#1-调用微信-chooseImage-接口，成功后调用-uploadImage-接口" class="headerlink" title="1.调用微信 chooseImage 接口，成功后调用 uploadImage 接口"></a>1.调用微信 chooseImage 接口，成功后调用 uploadImage 接口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseImage(&#123;</span><br><span class="line">               count: <span class="number">1</span>,</span><br><span class="line">               sizeType: [<span class="string">'original'</span>, <span class="string">'compressed'</span>],</span><br><span class="line">               sourceType: [<span class="string">'album'</span>, <span class="string">'camera'</span>],</span><br><span class="line">               success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                   $scope.localIds = res.localIds; <span class="comment">//存储localId供本地预览</span></span><br><span class="line">                   wx.uploadImage(&#123;</span><br><span class="line">                       localId: res.localIds[<span class="number">0</span>],</span><br><span class="line">                       isShowProgressTips: <span class="number">1</span>,</span><br><span class="line">                       success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                           WishData.mediaId = res.serverId; <span class="comment">//图片上传成功后保存serverId然后发给后台，让后台根据serverId去微信服务器下载对应的图片</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-在后台使用七牛的-fetch-接口向微信服务器请求文件并存入自己的七牛仓库"><a href="#2-在后台使用七牛的-fetch-接口向微信服务器请求文件并存入自己的七牛仓库" class="headerlink" title="2.在后台使用七牛的 fetch 接口向微信服务器请求文件并存入自己的七牛仓库"></a>2.在后台使用七牛的 fetch 接口向微信服务器请求文件并存入自己的七牛仓库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> qiniu.rs.Client();</span><br><span class="line"><span class="keyword">var</span> random_key = <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>, <span class="number">15</span>); <span class="comment">//生成一个随机字符串来给图片命名</span></span><br><span class="line"><span class="comment">//调用七牛 fetch 接口，具体用法参照文档</span></span><br><span class="line">client.fetch(<span class="string">'http://file.api.weixin.qq.com/cgi-bin/media/get?access_token='</span> + req.session.apptoken + <span class="string">'&amp;media_id='</span> + req.body.mediaId, <span class="string">'gdutgirl'</span>, random_key, <span class="function"><span class="keyword">function</span>(<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (err) &#123;</span><br><span class="line">               <span class="built_in">console</span>.log(err.error);</span><br><span class="line">               next();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">'图片请求成功'</span>);</span><br><span class="line">               <span class="keyword">var</span> url = qiniu.rs.makeBaseUrl(<span class="string">'7xnxuw.com1.z0.glb.clouddn.com'</span>, random_key); <span class="comment">//生成图片的可访问url</span></span><br><span class="line">               req.body.imgurl = url;</span><br><span class="line">               next();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>文档：</p>
<p><a href="http://mp.weixin.qq.com/wiki/12/58bfcfabbd501c7cd77c19bd9cfa8354.html" target="_blank" rel="noopener">微信上传和下载多媒体文档</a><br><a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E4.B8.8A.E4.BC.A0.E5.9B.BE.E7.89.87.E6.8E.A5.E5.8F.A3" target="_blank" rel="noopener">微信 JS SDK 说明文档</a><br><a href="http://developer.qiniu.com/docs/v6/api/reference/rs/fetch.html" target="_blank" rel="noopener">七牛 fetch 接口说明文档</a></p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[我理解的从输入 url 到浏览器渲染页面的过程]]></title>
      <url>http://shijianwen.github.io/2015/10/25/enter-url-to-render/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;最近刚看完《计算机网络》，自己重新整理了一下关于输入 url 后会发生什么的问题，跟以前的理解不同的是现在对整个通信过程有了更多的了解，所以这里会偏重讲一下通信过程和一些概念。<br>&nbsp;&nbsp;&nbsp;&nbsp;当我们在浏览器中输入一个 url 时，大致会发生这些过程：</p>
<h3 id="1-检查输入"><a href="#1-检查输入" class="headerlink" title="1.检查输入"></a>1.检查输入</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先浏览器会检查你输入的值，确定是不是一个合法的 url，如果不是，浏览器就会调用设置里的默认搜索引擎进行搜索并跳转。</p>
<h3 id="2-获取目的-ip"><a href="#2-获取目的-ip" class="headerlink" title="2.获取目的 ip"></a>2.获取目的 ip</h3><a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这一步的目的是为了获取到目标网站的 ip 地址，因为我们一般输入的url都是域名，就像 <code>www.baidu.com</code> 这样的，但是浏览器只认识 ip 地址，所以这一步就是要把域名转换成 ip 地址，浏览器首先检查自身的 DNS 缓存，看看有没有这个网站的 DNS 查询记录，如果没有的话就查系统里的 DNS 缓存，如果还是没有呢就通过向自己的 DNS 服务器查询来获得 ip 地址，但是 DNS 服务器又在哪里呢？换句话说，DNS 服务器的 ip 地址又是什么呢？这时候就要说一下 DNS 这个东西了，DNS 的全称叫 Domain Name System 域名系统，目的是为了查询各个域名对应的 ip 地址，我们上网时一个非常重要的参数就是配置 DNS 服务器，以我们学校为例，当我们使用 iNode 客户端登陆校园网系统成功后，学校的 DHCP 服务器就会动态地帮我们分配这些上网的参数，其中包括本机的 ip，当前所处子网的网关服务器地址，子网掩码以及 DNS 服务器地址（关于网关和 DHCP 接下来再解释）。在拿到了 DNS 地址之后，我们访问网站的时候就可以向这个 DNS 服务器发送查询 ip 地址的请求了，DNS 服务器在收到这个请求之后会先检查一下自己的缓存看有没有这个域名的记录，如果有并且还没有过期的话就会把这个当作响应发送给请求的服务器，如果没有的话就要继续向上层 DNS 发出查询了，因特网里的 DNS 呈金字塔状，位于顶层的是根 DNS 服务器，它处理所有发过来的查询请求；再往下一层是顶级域 DNS 服务器，它们按照域名后缀分为 .com服务器、 .net服务器、 .org服务器这些，顾名思义， .com服务器只处理那些域名后缀是 .com 的请求而 .net服务器只处理 .net 域名的请求。权威 DNS 往下是具体到每个域名的次级域 DNS 服务器，也叫权威 DNS 服务器，比如 baidu.com 的 DNS服务器，该 DNS 服务器里面就存着所对应域名的 ip 地址（在这里就是 baidu.com的ip地址）。一般来说，如果 DNS服务器 在自己的缓存中找不到符合响应要求的数据的话就会发一个请求给 根DNS，根DNS 检查你请求的域名然后根据它的后缀发给对应的 顶级域DNS，顶级域DNS 又根据具体的域名发给自己管辖下的 权威DNS，直到找到目标 ip  地址。经过这么复杂的步骤，我们终于拿到了目的地的 ip 地址。</p>
<h3 id="3-建立连接"><a href="#3-建立连接" class="headerlink" title="3.建立连接"></a>3.建立连接</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们知道了目的地的 ip 之后，就可以向那个地址发送请求了，但是发送请求之前我们需要先建立一个连接，因为我们的浏览器是使用 TCP 协议的，TCP 协议的一个特点就是它是面向连接的，与之相对的一个协议就是 UDP 了，UDP 是一个无连接的协议，这两者各有优缺，也有各自适用的场景，在此不做讨论。建立 TCP 连接的步骤是经过一个叫做 “三次握手” 的通信过程实现的，我们可以简单的理解成这样：首先，浏览器发送一个特殊的 TCP 报文给 baidu.com 的服务器，baidu.com 的服务器收到这个报文后对这个报文进行确认，这是第一次握手，之后服务器会发送一个确认收到这个特殊报文的响应给浏览器，浏览器收到服务器发回来的报文之后就完成了第二次握手，然后浏览器再发送一个确认收到的报文给服务器进行第三次握手，三次握手完毕后即说明连接已经建立好可以发送 http 请求了，一般浏览器在第三次握手的时候发送确认报文的时候也可以同时加入一些真实的资源请求了。</p>
<h3 id="4-发送请求，接受响应"><a href="#4-发送请求，接受响应" class="headerlink" title="4.发送请求，接受响应"></a>4.发送请求，接受响应</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;经过第三步我们建立了一个基本的 TCP 连接之后，我们就可以开始正常的发送请求和接受响应了，拿我们一开始输入的 url <code>baidu.com</code> 来说，连接建立之后浏览器会向百度的服务器请求 baidu.com 域名下的首页资源，服务器接收到这个请求后，会根据后台逻辑返回相应的内容给浏览器，比如现在返回一个 html 页面给浏览器，浏览器接收到这个响应后就开始渲染这个页面，在渲染之前浏览器会先扫描一遍页面的结构，把里面引用的一些超链接形式的静态资源（如 CSS，JS，图片等）重新像刚才那样发送请求去请求回来。但是这个请求是有先后顺序的，而且不同的文件类型有不同的加载性质，比如 js 文件加载的时候会阻塞整个页面的渲染，这个时候浏览器必须停下来等待这个 js 加载完毕后才能继续渲染页面，这也是为什么优化建议里会要求我们把 js 文件放到页面底部去加载的原因，就是为了不让 js 的加载阻塞页面渲染，避免导致页面出现一个长时间的空白期，从而提高用户体验。照这么说的话，那么 css 文件能不能放到页面底部来提高网页性能呢？答案是否定的，因为如果把 css 也放在底部，那么在 css 完成渲染之前，页面会停留在一段没有样式的时间内，这会导致用户看到一个完全没有样式的页面，这还不是重点，重点是 css 的下载和渲染是同时进行的，后面下面的 css 会覆盖掉前面定义过的 css，每次覆盖都会重新渲染前面的元素，这也是 css 为什么叫层叠样式表的原因（它就是这样一层叠一层地渲染的）。这样的后果就是重复渲染导致的闪屏，这样对用户来说也是很难忍受的。到此为止，整个请求的流程到渲染就差不多这样了，其中还有很多地方是这里没有详细展开来讲比如 css 渲染的特点、优化建议以及涉及到计算机网络更详细的通信过程之类的，我会在别的文章里专门写出来。 </p>
<h3 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h3><p><strong><em>什么是 DHCP？</em></strong><br>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是指在局域网中用来动态给各个用户分配 ip 地址的一个协议，我们在系统中打开本地连接的属性里的 ipv4 面板时：<br><img src="http://b.hiphotos.baidu.com/exp/w=480/sign=f1d1578c4d086e066aa83e4332097b5a/bf096b63f6246b60457b79c9eaf81a4c510fa212.jpg" alt="此处输入图片的描述"></p>
<p>  会发现我们可以选择自动获取 ip 地址或者手动配置 ip 地址，这里的自动获取 ip 地址就是指通过 DHCP服务器 来获取 ip地址。使用 DHCP 的目的有两个，一个是刚刚说的动态分配地址，另一个就是方便网络的集中管理。为什么要动态地分配地址？一个是为了减轻网络管理员的工作，避免手动地去配置每台机器的地址，另一个也是为了避免人工配置失误引起的地址冲突，另外一个，拿学校举例子，如果学校有两万个终端用户，突然有一天学校把校园网从电信网换成了网通网，因为不同的网络供应商使用的 ip 地址块是不一样的，所以一旦这种情况发生，在没有 DHCP 的情况下我们只能给这两万台机器重新配置新的 ip 地址。再另一个，如今接入互联网的设备越来越多，每个上网的设备都需要一个 ip 地址，随着设备数量的爆炸增长，总有一天 ip 地址会不够用，事实是现在 ip 地址已经完全不够了，因为 ip 地址的长度被限定在四个字节，它能提供的 ip 地址数量是有限的，如果要给所有设备都分配一个静态地址实在是有点奢侈，使用 DHCP 的好处就是可以做到按需分配，假如我们学校有两万电脑，但是学校发现我们的在线峰值是一万台机器同时上网，基于这样的事实我们使用 DHCP 就能够节省 ip 地址的开销，即只有当有人上网的时候服务器才从 ip 地址池里面取一个地址出来给这个用户而不是让这个用户永远占据这个地址。如今为了解决 ip 地址短缺的问题，因特网推出了新的 ip 地址 ipv6，它的一个主要变化就是长度变得更长了，能够分配更多的 ip 地址了。</p>
<p><strong><em>什么是网关？</em></strong><br>网关就是一个局域网内特殊的路由器，就好像我们要出大学城要经过收费站那样，每一个从局域网发出到公共因特网上以及从公共因特网上要发到局域网里头的请求都要经过网关路由器的跳转才能完成，它相当于一道关卡，守着本地局域网跟公共因特网之间的接口，一夫当关，万夫莫开。网关路由器的地址在你的主机向 DHCP 请求连接的时候会和 ip 地址这些配置参数一同发送给你的主机。</p>
<p><strong><em>什么是子网掩码？</em></strong><br>我们发现连同 ip 地址和网关地址发过来的还有一个叫做子网掩码的东西，它跟 ip 一样是 32 位长，使用子网掩码的目的是区分一个 ip 地址的对外部分（网络地址）和对内部分（主机号）。对外部分是用来识别具体到哪一个局域网的，这部分是不变的；对内部分是用来识别局域网内具体到哪一台主机的，其中对外部分用 1 标识，对内部分用 0 标识，假如我一个局域网一共有 7 个 ip，分别是 192.168.1.249 到 192.168.1.255，化解成 32 位的 ip 地址就是 <code>11000000.10101000.00000001.11111001</code> 到 <code>11000000.10101000.00000001.11111111</code> 可以看到我这一个局域网里头的 ip 地址变化只是体现在最后 3 位上，所以这里对外部分就是前 29 位，对内部分就是后 3 位，分别用 0 和 1 进行标识可以得到子网掩码位 <code>11111111，11111111，11111111，11111000</code> 转换成十进制就是 255.255.255.248，这就是我们要的子网掩码。当一个数据报在公共因特网上广播的时候，各个局域网的网关都会收到这个数据报，这时候网关就会把数据报的目的地址和自己的子网掩码匹配从而确定这个数据报是不是发给自己局域网内的，如果是则接收，否则丢弃，这样能够极大地提高局域网的安全性，也能及时拦截那些不是发给自己的数据报，避免浪费性能。</p>
]]></content>
      
        <categories>
            
            <category> Web 开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 HTML5 原生表单验证来控制 Ajax 请求的发送]]></title>
      <url>http://shijianwen.github.io/2015/09/22/html5-control-ajax/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;HTML5 原生的表单验证默认是针对 form 表单的请求行为的，但是有时候我们在发送 ajax 请求时也需要用到原生表单的验证功能，具体例子如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">"return false;"</span> <span class="attr">id</span>=<span class="string">"myform"</span>&gt;</span> //绑定 onsubmit 事件阻止原生表单请求</span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">required</span> <span class="attr">maxlength</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">    密码:   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> <span class="attr">id</span>=<span class="string">"submit_btn"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myform = <span class="built_in">document</span>.getElementById(<span class="string">'myform'</span>),</span></span><br><span class="line"><span class="javascript">        btn    = <span class="built_in">document</span>.getElementById(<span class="string">'submit_btn'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> isValid; <span class="comment">//定义一个全局变量存储表单是否正确</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="actionscript">    myform.addEventListener(<span class="string">'invalid'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">//注册 invalid 事件，表单验证不通过时触发</span></span></span><br><span class="line"><span class="actionscript">        isValid = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> sendRequest = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="comment">//将 ajax 请求写成一个函数，并在里面判断表单验证是否通过，通过则发送请求</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(isValid) &#123;</span></span><br><span class="line"><span class="undefined">            /*</span></span><br><span class="line"><span class="undefined">            ajax 请求代码</span></span><br><span class="line"><span class="undefined">            */</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="actionscript">    btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        isValid = <span class="literal">true</span>; <span class="comment">//默认表单是正确的</span></span></span><br><span class="line"><span class="undefined">        setTimeout(sendRequest, 0); </span></span><br><span class="line"><span class="actionscript">        <span class="comment">/*这里是一个重点，必须使用一个 setTimeout 来调用请求函数，这是因为 DOM 事件，Ajax，SetTimeout 都是异步执行，上面注册的 invalid 事件里面，它的回调函数的执行是异步的，所以如果这里不使用 setTimeout 将请求发送函数放入回调队列里面，就会由于变量 isValid 的值默认是 true 而使得表单验证一直都是通过的状态*/</span></span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之深入理解闭包]]></title>
      <url>http://shijianwen.github.io/2015/09/12/javascript-closure/</url>
      <content type="html"><![CDATA[<p><strong><em>变量的作用域</em></strong><br>作用域分为全局作用域和局部作用域，因为 JS 里没有块级作用域的概念，所以所谓的局部作用域是指函数内部的作用域，因为 JS 里函数外部是无法访问到函数内部的变量的，而函数内部却可以访问函数外部的变量，由此形成了局部作用域。</p>
<p>这里要注意一点，声明变量的时候一定要带上 var 关键字，如果没有 var 关键字则默认声明一个全局变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n); </span><br><span class="line">&#125;</span><br><span class="line">func1();<span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong><em>闭包</em></strong><br>由于作用域的这个特性，使得从外部访问函数内部的变量变得不可能，但是也不是全无办法，我们可以在函数内部再定义一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getN = func1();</span><br><span class="line">getN();<span class="comment">//输出 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 func1 里面又定义了一个内部函数 func2，这时候 func1 里面的所有变量对 func2 来说都是可见的， 这样我们在外部就可以通过里面的这个 func2 函数来访问 func1 内部的变量了,这个内部函数 func2，就叫做闭包。</p>
<p>从概念上来说，闭包就是能够访问函数内部变量的函数。</p>
<p><strong><em>闭包的用途</em></strong><br>闭包的用途主要有两个，一个是用来访问函数内部变量，另一个是让某些变量保持在内存中不会被 GC 回收：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">    nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        n+=<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = func1();</span><br><span class="line">result();<span class="comment">//999</span></span><br><span class="line">nAdd();</span><br><span class="line">result();<span class="comment">//1000</span></span><br></pre></td></tr></table></figure></p>
<p>正常情况下，一个函数在调用结束之后就会被垃圾回收机制回收，此时函数作用域里面的所有变量都会被销毁，所以正常情况下上面运行两次输出的应该都是 999，因为运行完一次后所有变量都会被销毁，但是这里没有，这里在运行两次后 n 的值累加了，这说明变量 n 没有被回收，它一直都在内存里面。<br>这是因为 func2 被赋值给了全局变量 result，使得 func2 一直保持在内存中(因为 result 是全局变量，浏览器不关闭，全局变量就一直存在)，而且 func2 又是依赖于 func1 的（要引用 func2 必先调用 func1），所以只要 func2 还在，func1 也一定在。</p>
<p>闭包还有一个用途就通过闭包可以建立对象的私有属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateVar = <span class="string">'private'</span>;<span class="comment">//定义私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicVar: <span class="string">'public'</span>, <span class="comment">//公有变量</span></span><br><span class="line">        publicFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//公有方法，也是特权方法</span></span><br><span class="line">            <span class="built_in">console</span>.log(privateVar);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(someObject.privateVar); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(someObject.publicFunc());<span class="comment">//输出 private</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码 someObject 定义了一个立即执行的匿名函数，这个函数的执行结果是返回了一个匿名对象，匿名对象里定义了一个公有变量和一个公有方法，这两个属性都是对外公开的，然而因为这个函数是立即执行的，并且是一个匿名函数，所以我们从外部是无法访问到函数内部定义的 privateVar 这个变量的，只能通过函数返回的公有方法 publicFunc，因为函数内部变量对这个公有方法来说是公开的，所以这个公有方法也被叫做特权方法。可以看到，利用了闭包技术，可以一定程度上弥补 JavaScript 天生的缺陷，使它更像一门真正的面向对象语言，因为在原生的 JavaScript 里面是没有定义像传统面向对象语言那样的诸如块级作用域，私有变量，特权方法这些东西的。</p>
<p>P.S 参考文献：<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">如何学习 JavaScript 闭包  –阮一峰</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之 this 关键字]]></title>
      <url>http://shijianwen.github.io/2015/07/18/javascript-this/</url>
      <content type="html"><![CDATA[<p>this 是 JavaScript 的一个关键字，它表示函数在运行的时候所处的执行环境，this 的值会随着执行环境的不同动态变化，总的来说，this 指的是当前调用函数的那个对象。我们常在一下几种情况下使用 this：</p>
<p><strong><em>纯函数调用</em></strong></p>
<p>在纯函数调用的情况下，this 指向全局环境：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">//定义全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">//这里是一个局部变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">&#125;</span><br><span class="line">getA(); <span class="comment">//输出 1</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong><em>作为对象的方法调用</em></strong></p>
<p>当作为某个对象的方法调用时，this 指向这个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 2; //定义一个全局变量（为了说明 this 不是指向全局环境）</span><br><span class="line">function getA () &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var someObject = new Object(); //定义一个对象</span><br><span class="line">someObject.a = 1;  //定义这个对象下的一个变量</span><br><span class="line">someObject.func1 = getA;</span><br><span class="line">someObject.func1(); //输出 1</span><br></pre></td></tr></table></figure></p>
<p><strong><em>作为构造函数调用</em></strong></p>
<p>当作为构造函数调用时，this 指向由这个构造函数生成的新对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123; <span class="comment">//定义构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> onePerson = <span class="keyword">new</span> Person(); <span class="comment">//实例化一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(onePerson.a); <span class="comment">//输出 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>apply 调用</em></strong><br>当 apply 参数为空时，this 指向全局环境，如果不为空，则指向参数所代表的环境：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someObject = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//定义一个对象</span></span><br><span class="line">someObject.a = <span class="number">2</span>;</span><br><span class="line">getA.apply(); <span class="comment">//输出 1</span></span><br><span class="line">getA.apply(someObject) <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM & BOM]]></title>
      <url>http://shijianwen.github.io/2015/07/16/DOM-BOM/</url>
      <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM 即是浏览器对象模型（Browser Object Model），它定义了 JavaScript 可以进行操作的浏览器的各个功能部件的接口，提供访问文档各个功能部件（如窗口本身、屏幕功能部件、浏览历史记录等）的途径以及操作方法。遗憾的是，BOM只是JavaScript脚本实现的一部分，没有任何相关的标准，每种浏览器都有自己的 BOM 实现，这是 BOM 最大的缺陷，在浏览器 JavaScript 中，BOM 主要有以下几个功能：</p>
<p>◆关闭、移动浏览器及调整浏览器窗口大小；<br>◆弹出新的浏览器窗口；<br>◆提供浏览器详细信息的定位对象；<br>◆提供载入到浏览器窗口的文档详细信息的定位对象；<br>◆提供用户屏幕分辨率详细信息的屏幕对象；<br>◆提供对cookie的支持；<br>◆加入ActiveXObject类扩展BOM，通过JavaScript实例化ActiveX对象。</p>
<a id="more"></a>
<h3 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h3><p>在 BOM 中，Window 对象是所有对象的核心，它是 BOM 中所有对象的父对象。</p>
<p><strong><em>1.全局的 Window 对象</em></strong><br>在浏览器中，Window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的全局对象，所有全局变量和全局函数都会归类成 Window 对象的属性。但是虽说全局变量会自动变成 Window 对象的属性，但全局变量跟显式定义的 Window 对象属性还是有一些差别的，差别在于全局变量不可以用 delete 操作符删除而 Window 对象属性可以，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  <span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="built_in">window</span>.b = <span class="number">2</span>; <span class="comment">//定义一个 window 属性</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//输出 false</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//输出 1</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.b; <span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>2.兼容问题</em></strong><br>由于 BOM 并没有一套系统的规范来约束它，所以在使用一些浏览器窗口的方法的时候需要对不同的浏览器进行兼容，以确定窗口位置的这个方法为例，在 IE、Safari、Opera 和 Chrome 浏览器下使用 screenLeft 和 screenTop 属性来获取窗口与屏幕左边和上边的距离，而在 FireFox 浏览器中则要通过 screenX 和 screenY 来获取，这种情况下为了能够在各种浏览器下都能正常使用这个方法，我们就需要改写代码去兼容各个浏览器，具体写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IE、Safari、Opera 和 Chrome 使用 screenLeft 和 screenTop 属性</span></span><br><span class="line"><span class="comment">//Firefox 则使用 screenX 和 screenY</span></span><br><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line"><span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line"><span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>3.超时调用 setTimeout 和间歇调用 setInterval</em></strong><br>setTimeout 和 setInterval 都是 Window 对象中常用的方法，从名称上来看，超时调用 setTimeout 是在等待一段时间后去执行一个函数，它接收两个参数，第一个参数是要执行的函数，第二个参数是要等待的时长，它的单位是毫秒。间歇调用 setInterval 是每隔一段时间就执行一次函数，它也接收两个参数，两个参数跟 setTimeout 的一样。<br>setTimeout 和 setInterval 方法在调用的时候都会返回一个独一无二的数字 ID 用以识别当前的计时器，我们在代码中一般都会定义一个变量来保存这个数字 ID，以便给后来需要的 clearTimeout 和 clearInterval 传递参数。<br>setTimeout 和 setInterval 都有各自相对应的一个 clear 方法，分别是 clearTimeout 和 clearInterval，它们的作用是用来阻止超时调用和间歇调用的进行，它们都接收一个参数，就是上面说的数字 ID。对超时调用 setTimeout 来说，如果等待时间还没完的情况下就执行 clearTimeout 函数的话就会终止执行，如果等待时间已经完成的话则 clearTimeout 对其无效。clearInterval 比较简单，它就是用来终止间歇调用的循环的。<br>超时调用 setTimeout 的调用例子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用例子如下</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'哈哈哈'</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次调用都会返回一个独一无二的数字代码用于识别这个计时器，以用来取消</span></span><br><span class="line"><span class="comment">//取消计时器可使用 clearTimeout，参数为 setTimeout 返回的数字代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"哈哈哈哈"</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line">clearTimeout(timer);</span><br></pre></td></tr></table></figure></p>
<p>间歇调用 setInterval 的调用例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个间歇调用例子</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"蛤蛤"</span>);</span><br><span class="line"><span class="comment">//如果执行次数达到了 max 设定的值,则取消后续尚未执行的调用</span></span><br><span class="line"><span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">clearInterval(intervalId);</span><br><span class="line">alert(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>我们还可以利用一些技巧使用超时调用 setTimeout 来模仿间歇调用 setInterval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以使用超时调用来模拟间歇调用</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="comment">//如果执行次数未达到 max 设定的值,则设置另一次超时调用</span></span><br><span class="line"><span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"蛤蛤"</span>);</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>此处有一个点需要注意，当使用 setInterval 的时候，如果处理的函数比较费时的话，会出现函数堆积的情况，因为 setInterval 的计时并不会等待函数执行完毕，也就是说，假设我的间隔时长为 500ms，而我的函数执行需要 1000ms，当我第一次调用的函数还没有执行完的时候，第二次调用又已经开始了，这样函数堆积起来不光影响性能，还会导致计时混乱，因为我们直观理解的间隔计时就是第一个函数执行完毕到第二个函数开始执行的这段时间。当使用 setTimeout 模拟的间歇调用的时候就不会出现这种情况，同时它的计时也是从一个函数结束开始计时的。所以一致推荐使用 setTimeout 来模拟间歇调用。</p>
<p><strong><em>4.JavaScript 执行机制</em></strong></p>
<p>既然说到了 setTimeout，那这里也就有必要提一下 JavaScript 的执行机制了，作为一门网页脚本语言，JavaScript 的用途决定了它单线程的命运，在单线程里，所有的代码都是同步执行的，也就是说，后面的代码必须要等待前面的代码执行完毕之后才能被执行到，这是一种效率极低方式，特别是当前面的代码有涉及到设备 IO 和数据库存取等耗时操作时，整个线程将会处于挂起状态，严重情况下甚至会导致整个网页失去响应，因为在等待状态的时候网页是没有办法响应用户操作的，这也就是常说的代码阻塞，特别是很多时候当处于阻塞状态时，CPU 的负载并不高，这就在另一方面造成了性能的浪费。超时调用 setTimeout 就是一个非常常见的阻塞操作，除此之外还有 Ajax 的异步请求以及 DOM 事件。</p>
<p>JavaScript 的执行机制正是为了解决它的单线程的局限性而来的，它的基本想法是这样的：<br>对于那些比较耗时的操作（DOM，Ajax，setTimeout 这些），可以暂时把它们放到别的地方去让它们自己去执行，我的主线程继续执行这之后的代码，当那些耗时操作在另一个地方执行完毕的时候，再把该操作对应的回调函数加入到主线程中来去执行，这就是异步操作，所以在 JavaScript 代码里会同时存在同步任务和异步任务，同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务是指不在主线程上执行的任务，它必须带有回调函数，用于异步任务执行完毕之后进行后续的处理。</p>
<p>在 JavaScript 的底层实现中，执行机制一般有以下几步：<br>一、按顺序扫描代码，把所有同步任务加入主线程，形成一个执行栈；<br>二、把扫描到的异步任务另外执行，并在异步任务执行完毕后放入到一个“回调队列”中，处于等待被执行的状态；<br>三、当执行栈中的所有任务执行完毕时，系统就会读取”回调队列”，让最早排队的那个事件结束等待状态，进入执行栈，开始执行。<br>四、重复第三步。</p>
<p>用图表示如下：<br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/EventLoop.png" alt="此处输入图片的描述"><br>图中的 stack 即为执行栈，WebAPIs 为异步任务执行的地方，图下方是一个回调队列，回调队列与执行栈之间有一个“事件循环（Event Loop）”的东西，它是用来监视执行栈的，一旦执行栈里的任务全部执行完毕后，事件循环会马上从回调队列里取出一个位于队列头部的事件，把它丢进执行栈中执行。</p>
<p>这里举一个执行机制的例子，我们知道 setTimeout 是异步任务的一种，在一开始它是不会进入执行栈的，我们先写一段代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'1'</span>);&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码的第一行是一个超时调用 setTimeout，它是一个异步任务，第二行代码是一个控制台输出，它是一个同步任务。在执行的时候，setTimeout 不会进入执行栈，而是在别的地方进行它的计时，当计时结束后会进入回调队列等待被事件循环加进执行栈中执行，在这期间代码会继续往下执行，所以这段代码最终的运行结果是先在控制台输出 2，最后再在控制台输出 1。如果现在你能理解这个例子，那就说明你已经对执行机制有了初步的了解，在执行机制的基础上还有很多复杂的运用，后面我们还会遇到越来越难的东西。</p>
<p>从上面这么多的解释我们还可以发现一个小特性，那就是</p>
<p>由于事件机制的存在，使得 setTimeout 并不完全会在指定的时间后被执行，知道是为什么吗？因为当计时结束的时候，setTimeout 里面的函数只是被加到了回调队列里，除非此时执行栈是空的，否则就还会有一段等待的时间，当然这段时间也不光是等待执行栈清空的时间，也包含了等待回调队列前面的函数被执行的时间。</p>
<h3 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h3><p>location 对象既是一个 Wwindow 对象的属性，也是一个 Ddocument 对象的属性，它可以访问当前浏览器 URL 的字符串信息，也可以通过更改浏览器位置信息来实现 URL 跳转等操作，具体看书，此处上图两张。<br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/1406945151689398.png" alt="此处输入图片的描述"><br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/Location_URL.png" alt="此处输入图片的描述"></p>
<h3 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h3><p>Navigator 对象一般用来查看浏览器的各种版本信息，也可以用来检测插件，但最常用的还是用它查看浏览器的代理信息从来进行浏览器兼容。<br>方法：<br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/Navigator.png" alt="此处输入图片的描述"></p>
<p>用户代理信息：<br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/UA.png" alt="此处输入图片的描述"></p>
<p>除此之外，没有介绍的还有 Hhistory 对象和 Sscreen 对象，这几个都是不常用的，而且兼容问题也很严重，浏览器长年累月的各成一派已经使得拥有一个跨浏览器的解决方案的难度非常大。<br>其中，Hhistory 对象有如下特点<br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/1406944676467640.png" alt="此处输入图片的描述"></p>
<h3 id="浏览器兼容（客户端检测）"><a href="#浏览器兼容（客户端检测）" class="headerlink" title="浏览器兼容（客户端检测）"></a>浏览器兼容（客户端检测）</h3><p><strong><em>1.能力检测</em></strong><br>最常用也最为人们广泛接受的客户端检测形式是能力检测(又称特性检测)。能力检测的目标不是<br>识别特定的浏览器,而是识别浏览器的能力。采用这种方式不必顾及特定的浏览器如何,只要确定<br>浏览器支持特定的能力,就可以给出解决方案。能力检测的基本模式如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IE5.0 之前的版本不支持 document.getElementById() 这个 DOM 方法。尽管可以使</span></span><br><span class="line"><span class="comment">//用非标准的 document.all 属性实现相同的目的,但 IE 的早期版本中确实不存在 document.get-</span></span><br><span class="line"><span class="comment">//ElementById() 。于是,也就有了类似下面的能力检测代码:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.all[id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No way to retrieve element!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行能力检测的时候一定要检测实际用到的特性，不能根据能力检测来判断当前浏览器</span></span><br><span class="line"><span class="comment">//最好使用 typeof 操作符去进行能力检测，因为你检测的目标很可能是某个对象的属性</span></span><br><span class="line"><span class="keyword">if</span>(object.sort)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;<span class="comment">//这样写是不对的，万一我有某个对象刚好有个属性叫做 sort 呢？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> object.sort == <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;<span class="comment">//这样写比较好</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>2.怪癖检测</em></strong><br>与能力检测类似,怪癖检测的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同,怪癖检测是想要知道浏览器存在什么缺陷(也就是 bug)。由于检测“怪癖”涉及运行代码,因此建议仅检测那些对你有直接影响的“怪癖”<br>,而且最好在脚本一开始就执行此类检测,以便尽早解决问题。</p>
<p><strong><em>3.用户代理检测</em></strong><br>程序通过检测用户代理字符串来识别浏览器。用户代理字符串中包含大量与浏览器有关的信息,包括浏览器、平台、操作系统及浏览器版本。用户代理字符串有过一段相当长的发展历史,在此期间,浏览器提供商试图通过在用户代理字符串中添加一些欺骗性信息,欺骗网站相信自己的浏览器是另外一种浏览器。用户代理检测需要特殊的技巧,特别是要注意 Opera 会隐瞒其用户代理字符串的情况。即便如此,通过用户代理字符串仍然能够检测出浏览器所用的呈现引擎以及所在的平台,包括移动设备和游戏系统。</p>
<p>在决定使用哪种客户端检测方法时,一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理代码的第二选择。而用户代理检测则是客户端检测的最后一种方案,因为这种方法对用户代理字符串具有很强的依赖性（而用户代理字符串可能具有欺骗性）。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 是文档对象模型 (Document Object Model) 是 HTML 和 XML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将  Web 页面和脚本或程序语言连接起来。</p>
<p>###节点类型<br>Node.ELEMENT_NODE (1);（元素节点）<br>Node.ATTRIBUTE_NODE (2);（属性节点）<br>Node.TEXT_NODE (3);（文本节点）<br>Node.CDATA_SECTION_NODE (4);<br>Node.ENTITY_REFERENCE_NODE (5);<br>Node.ENTITY_NODE (6);<br>Node.PROCESSING_INSTRUCTION_NODE (7);<br>Node.COMMENT_NODE (8);<br>Node.DOCUMENT_NODE (9);（文档节点）<br>Node.DOCUMENT_TYPE_NODE (10);<br>Node.DOCUMENT_FRAGMENT_NODE (11);<br>Node.NOTATION_NODE (12)。</p>
<p>其中最重要的节点类型有三个：元素节点，属性节点，文本节点</p>
<p>在确定元素节点类型的时候有两种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种是把节点的 nodeType 属性跟节点类型的名称作比较，这种方法在 IE 下不适用</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE) &#123; <span class="comment">//如果成立则是元素节点</span></span><br><span class="line">    alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般采用的是这第二种方法，跟节点类型对应的数字作比较</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">    alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>节点属性</em></strong><br>节点有三个最重要的属性：</p>
<ol>
<li>nodeName : 节点的名称</li>
<li>nodeValue ：节点的值</li>
<li>nodeType ：节点的类型</li>
</ol>
<p>一、nodeName 属性: 节点的名称，是只读的。</p>
<ol>
<li>元素节点的 nodeName 与标签名相同</li>
<li>属性节点的 nodeName 是属性的名称</li>
<li>文本节点的 nodeName 永远是 #text</li>
<li>文档节点的 nodeName 永远是 #document</li>
</ol>
<p>二、nodeValue 属性：节点的值</p>
<ol>
<li>元素节点的 nodeValue 是 undefined 或 null</li>
<li>文本节点的 nodeValue 是文本自身</li>
<li>属性节点的 nodeValue 是属性的值</li>
</ol>
<p>三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">元素类型    节点类型</span><br><span class="line">   元素          <span class="number">1</span></span><br><span class="line">   属性          <span class="number">2</span></span><br><span class="line">   文本          <span class="number">3</span></span><br><span class="line">   注释          <span class="number">8</span></span><br><span class="line">   文档          <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">childNodes  <span class="comment">//访问当前元素的所有子节点</span></span><br><span class="line">firstChild  <span class="comment">//访问第一个子节点</span></span><br><span class="line">lastChild   <span class="comment">//访问最后一个子节点</span></span><br><span class="line">parentNode  <span class="comment">//访问父节点</span></span><br><span class="line">nextSibling <span class="comment">//访问下一个兄弟节点</span></span><br><span class="line">previousSibling <span class="comment">//访问前一个兄弟节点</span></span><br></pre></td></tr></table></figure>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建节点的方法：</span></span><br><span class="line">createElement()</span><br><span class="line">createTextNode()</span><br><span class="line"></span><br><span class="line"><span class="comment">//向 chileNodes 末尾添加一个节点，返回值为新添加的这个节点</span></span><br><span class="line">appendChild ()</span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br><span class="line">alert(returnedNode == newNode);<span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode);<span class="comment">//true</span></span><br><span class="line"><span class="comment">/*如果传入到 appendChild() 中的节点已经是文档的一部分了,那结果就是将该节点从原来的位置</span></span><br><span class="line"><span class="comment">转移到新位置。即使可以将 DOM 树看成是由一系列指针连接起来的,但任何 DOM 节点也不能同时出</span></span><br><span class="line"><span class="comment">现在文档中的多个位置上。因此,如果在调用 appendChild() 时传入了父节点的第一个子节点,那么</span></span><br><span class="line"><span class="comment">该节点就会成为父节点的最后一个子节点*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把节点插入到某个子节点之前</span></span><br><span class="line">insertBefore() </span><br><span class="line"><span class="comment">/*这个方法接受两个参数:要插入的节点和作为参照的节点。插入节点后,被插入的节点会变成参照节点的前一个同胞节点( previousSibling ),同时被方法返回。如果参照节点是 null ,则 insertBefore() 与 appendChild() 执行相同的操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入后成为最后一个子节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>);</span><br><span class="line">alert(newNode == someNode.lastChild);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//插入后成为第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.insertBefore(newNode, someNode.firstChild);</span><br><span class="line">alert(returnedNode == newNode);<span class="comment">//true</span></span><br><span class="line">alert(newNode == someNode.firstChild); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//插入到最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild);</span><br><span class="line">alert(newNode == someNode.childNodes[someNode.childNodes.length<span class="number">-2</span>]); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">replaceChild()</span><br><span class="line"><span class="comment">//replaceChild() 方法接受的两个参数是:要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中//被移除,同时由要插入的节点占据其位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</span><br><span class="line"><span class="comment">//替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild);</span><br><span class="line"><span class="comment">//replaceChild 并不是将被替换的节点完全抹去，只是把它的指针替换，它本身并没有消失，还是真实存在的，但是文档中已经没有它的位置了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只想移除而非替换节点,可以使用 removeChild() 方法。这个方法接受一个参数,即要移除的节点。</span></span><br></pre></td></tr></table></figure>
<h3 id="Document-操作"><a href="#Document-操作" class="headerlink" title="Document 操作"></a>Document 操作</h3><p>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByName()</p>
<h3 id="Element-操作"><a href="#Element-操作" class="headerlink" title="Element 操作"></a>Element 操作</h3><p>操作各个元素的属性的方法有两种：一种是用编程方式去访问节点对象，一种是用 Element 操作，Element 操作使用下面三种方法：<br><strong><em>getAttribute()</em></strong><br>接收一个参数，即需要获取值的属性名，该方法返回当前节点的目标属性的属性值。</p>
<p><strong><em>setAttribute()</em></strong><br>接收两个参数，一个是属性名，第二个是属性值，用于设置当前节点的属性。</p>
<p><strong><em>removeAttribute()</em></strong><br>接收一个参数，即属性名，移除当前节点的该属性。</p>
<p>有两类特殊的特性,它们虽然有对应的属性名,但属性的值与通过 getAttribute() 返回的值并不相同。第一类特性就是 style ,用于通过 CSS 为元素指定样式。在通过 getAttribute() 访问时,返回的 style 特性值中包含的是 CSS 文本,而通过编程属性来访问它则会返回一个对象。</p>
<p>第二类与众不同的特性是 onclick 这样的事件处理程序。当在元素上使用时, onclick 特性中包<br>含的是 JavaScript 代码,如果通过 getAttribute() 访问,则会返回相应代码的字符串。而在通过编程方式访问<br>onclick 属性时,则会返回一个 JavaScript 函数(如果未在元素中指定相应特性,则返回 null )<br>。这是因为 onclick 及其他事件处理程序属性本身就应该被赋予函数值。</p>
<p>由于存在这些差别,在通过 JavaScript 以编程方式操作 DOM 时,开发人员经常不使用 getAttri-<br>bute() ,而是只使用对象的属性。</p>
<p>这里先附一张 DOM 操作的思维导图，DOM 里面涉及到的操作都在图里：<br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/63918611gw1ek0h01ps7yg20ve1rowjt.gif" alt="此处输入图片的描述"></p>
<h3 id="DOM-拓展"><a href="#DOM-拓展" class="headerlink" title="DOM 拓展"></a>DOM 拓展</h3><p>querySelector 和 querySelectorAll<br>querySelector 和 querySelectorAll 是 DOM 选择符 API 里面新增的两个方法，它们支持以 CSS选择器 的形式去获取节点，这里不赘述。</p>
<p>querySelectorAll 与 getElementsBy 方法最大的不同就是它返回的是一个静态的 nodeList，而 getElementsBy 系列方法返回的是一个动态的 nodeList，看代码：</p>
<p><strong><em>HTML</em></strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>JavaScript</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo 1</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul'</span>)[<span class="number">0</span>],</span><br><span class="line">    lis = ul.querySelectorAll(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里使用 querySelectorAll 来获取所有 li 元素，方法返回一个 nodeList，然后执行一个相当于 nodeList 长度的循环，每次循环都新增一个 li，这段代码最终就产生三个新的 li*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo 2</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>], </span><br><span class="line">    lis = ul.getElementsByTagName(<span class="string">"li"</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length ; i++)&#123;</span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"li"</span>)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里使用了 document.getElementsByTagName 来获取 li 元素，同样执行一个 nodeList 长度的循环，但是这段代码会进入死循环，原因在于使用 document.getElementsByTagName 所返回的是一个动态的 nodeList，即 lis 变量是动态的，我每次访问这个变量，它都会重新计算新的值并且更新，所以我的 for 循环里每一次访问 lis.length，它都是不一样的，因为每次循环 lis 的长度都会增加，这样就使这段代码陷入的死循环，而上面的 querySelectorAll 方法恰恰相反，它返回的是一个静态 nodeList，它们两者之间最大的区别就在于此 */</span></span><br></pre></td></tr></table></figure></p>
<p>PS：这篇博文篇幅比较长，因为客户端 JavaScript 的内容实在不少，本文也只是选取了其中比较常用并且重要的知识进行介绍，要想全面理解客户端 JavaScript 还是要好好看书。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">JavaScript DOM 概述</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Git简易教程]]></title>
      <url>http://shijianwen.github.io/2015/07/13/Git%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong><em>初始化仓库</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<p><strong><em>查看仓库状态</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p>
<p><strong><em>查看修改信息</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></p>
<p><strong><em>版本回退</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p><strong><em>查看提交历史</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p>
<p><strong><em>查看命令历史</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong><em>丢弃工作区中的修改</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure></p>
<p><strong><em>丢弃暂存区中的修改</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename</span><br><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure></p>
<p><strong><em>删除文件</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br></pre></td></tr></table></figure></p>
<p><strong><em>生成 SSH Key</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>添加远程库</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure></p>
<p><strong><em>推送本地更新到远程库</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master   //如果第一次提交</span><br><span class="line">git push origin master      //之后的提交</span><br></pre></td></tr></table></figure></p>
<p><strong><em>从远程仓库克隆</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server-name:path/repo-name.git    //推荐使用 SSH 协议</span><br></pre></td></tr></table></figure></p>
<p><strong><em>分支操作</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch   //查看分支</span><br><span class="line">git branch [name] //创建分支</span><br><span class="line">git checkout [name] //切换分支</span><br><span class="line">git checkout -b [name] //创建并切换分支</span><br><span class="line">git merge [name]     //合并目标分支到当前分支</span><br><span class="line">git branch -d [name] //删除分支</span><br><span class="line">git log --graph      //查看分支合并图</span><br></pre></td></tr></table></figure></p>
<p><strong><em>查看远程库信息</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p>
<p><strong><em>推送到远程仓库的某个分支</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin [branch-name]</span><br></pre></td></tr></table></figure></p>
<p><strong><em>抓取远程更新</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p>
<p><strong><em>在本地创建跟远程分支对应的分支</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branch-name] [origin/branch-name]</span><br></pre></td></tr></table></figure></p>
<p><strong><em>本地分支和远程分支关联</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream [branch-name] [origin/branch-name]</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之深入理解继承]]></title>
      <url>http://shijianwen.github.io/2015/05/02/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;之前说到了创建对象的几种方法，所以决定在这里讲讲对象继承的几种方法，两者有所共通，如果这里的文章有何不解可以参考前一篇文章 <a href="http://shijianwen.github.io/2015/04/11/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B5%85%E6%9E%90%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/">JavaScript 学习笔记之创建对象的几种方法</a>。</p>
<h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><p>&emsp;&emsp;<strong><em>原型链</em></strong><br>&emsp;&emsp;在讲继承之前先来说一下关于原型链的事情，JavaScript 是依靠原型链来实现继承的，之前讲过构造函数，原型与实例之间的关系：每一个构造函数都会有一个自己的原型对象比如 Object.prototype，构造函数用一个内部属性 [[prototype]] 指向该原型对象；原型对象包含一个指向构造函数的指针 constructor；而每一个实例也都有一个指向原型对象的内部指针 <strong>proto</strong>。假设当前构造函数 A 的原型对象 A.prototype 等于另一个构造函数 B 的实例的话，那么此时 A.prototype 内部将会有一个指向构造函数 B 的原型对象 B.prototype 的指针，B.prototype 里也会有指向构造函数 B 的指针（<strong><em>因为刚才说了每一个实例都会有一个指向原型对象的内部指针 <strong>proto</strong>，所以如果我当前这个原型对象 A.prototype 是另一个构造函数 B 的实例的话它就有了双重身份了，也就是说这个原型对象 A.prototype 它现在既是一个原型对象也是一个实例，既然是构造函数 B 的实例，就一定会有一个指向 B.prototype 的指针，相应地，在 B.prototype 里面也会包含着一个指向构造函数 B 的指针</em></strong>）。同样的，如果此时 B.prototype 又是另外一个原型的实例的话，上述关系也依然成立，这样一直延续下去，就构成了一条原型链。用图表示出来就是这样：<br><a id="more"></a><br><img src="http://7xiuuj.com1.z0.glb.clouddn.com/scope.png" alt="原型链"></p>
<p>&emsp;&emsp;此外，所有引用类型的数据都是默认继承自 Object 的，所以任何一个引用类型数据的默认原型都是 Object 的实例，它们内部都有一个指针指向 Object.prototype，这也是所有引用类型数据都有 toString(),valueOf() 方法的原因，所以在上图的原型链中还应在最上方加入一个 Object 继承层次。实现原型链继承的代码基本如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fatherProperty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fatherProperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承父类</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.getSonValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> oneObject = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(oneObject.getFatherValue());</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的代码中，Son 类型继承自 Father 类型，我们把 Father 的实例赋给 Son 的原型，达到重写 Son 的原型对象的目的，也达到了实现原型链的目的（<strong><em>此时 Son 的原型内部有指向 Father 原型的指针</em></strong>）。实现原型链后，我们的原型搜索机制也会因此得到拓展，当我们访问一个实例属性的时候，首先会在当前实例中查找该属性，如果没有则会继续搜索该实例的原型，在通过原型链实现继承的情况下，该搜索过程会沿着原型链继续往上直到原型链末端。同时有一点需要注意的是，上面的代码中我们定义 Son 类型的 getSonValue 方法的时候是在继承父类之后才添加进去的，在使用原型链继承的时候特别要注意这一点，因为我们在继承父类的时候是通过重写子类原型对象的方法来实现继承的，如果我的子类原型方法定义在继承父类之前，那么当我继承父类重写原型对象的时候我之前定义的子类原型方法就会被擦除。</p>
<p>&emsp;&emsp;<strong><em>原型链的问题</em></strong><br>&emsp;&emsp;之前也讲到过，原型方式创建对象的问题就是引用类型数据的问题，在原型继承中这个问题也同样存在，原因跟用原型创建对象一样，原型属性中如果存在引用类型数据的话会被所有实例共享，如果你有多个实例，那么只要更改其中一个实例中的该属性，就会在所有实例中体现出来。除此之外，原型链继承的第二个问题就是很难在不影响所有实例的情况下给父类型的构造函数传递参数（<strong><em>因为不能通过传参在父类中定义属性，在父类中定义不符合面向对象编程的规则，属性应该由实例来定义，如果在父类定义，就会强制给所有实例继承这个属性</em></strong>）。基于这两个问题，实践中很少会单独使用原型链。</p>
<h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h3><p>&emsp;&emsp;在讲创建对象的几种方式的时候，我们也使用过构造函数来解决原型带来的问题，在这里也是如此，为了解决原型继承中引用类型值的问题，我们采用借用构造函数的方法，其基本原理就是：在子类型构造函数内部调用父类型的构造函数从而实现从父类型的继承，同样考虑到函数的执行环境，我们一般通过使用 <code>apply()</code> 或者 <code>call()</code> 方法来调用父类型构造函数。具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承父类</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> Object1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> Object2 = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改其中一个实例的值</span></span><br><span class="line">Object1.numbers.push(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Object1.numbers); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="built_in">console</span>.log(Object2.numbers); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码在子类中调用父类构造函数实现了继承，虽然 numbers 是引用类型值，但因为继承是在每一个子类中单独调用父类的，所以每一个实例都会拥有一份数据副本，不会共享。除此之外，借用构造函数还能解决原型链继承中不能向父类传递参数的问题，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,<span class="string">"ShiJianwen"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Object1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(Object1.name); <span class="comment">// ShiJianwen</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong><em>构造函数的问题</em></strong><br>&emsp;&emsp;虽然借用构造函数能够解决原型链的两大问题，但它自己也不是完美的，借用构造函数继承的时候，所有函数这些可复用的东西你都要重新定义一遍，因为实际上你就是通过构造函数在继承，每实例化一次你就重新定义一次所有属性和方法，所以根本没有代码复用性可言。还有一个问题也是由于构造函数继承导致的，那就是你父类型中原型里定义的所有东西都无法继承到子类中，只有在父类构造函数中定义的东西才能继承到子类，具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在父类型原型中定义属性和方法</span></span><br><span class="line">Father.prototype.Say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aa'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Father.prototype.age = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,<span class="string">"ShiJianwen"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Object1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(Object1.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Object1.Say()); <span class="comment">// Object1.Say() is not a function</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以一般也不建议使用这种方法继承。</p>
<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h3><p>&emsp;&emsp;组合继承是指结合原型继承和借用构造函数两种方法来实现继承的方法，它的本质是用原型链实现对原型属性和方法（可复用的代码）的继承，用构造函数实现对实例属性（不适合共享的代码）的继承。这样既能实现代码复用，也能实现每个实例都有自己的一套属性，是 JavaScript 中最常用的实现继承的方法。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.Say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用构造函数方法继承父类</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用原型链继承方法</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">var</span> Object1 = <span class="keyword">new</span> Son(<span class="string">"Sibarone"</span>, <span class="number">19</span>);</span><br><span class="line"><span class="keyword">var</span> Object2 = <span class="keyword">new</span> Son(<span class="string">"ShiJianwen"</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">Object1.numbers.push(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Object1.Say(); <span class="comment">// Sibarone</span></span><br><span class="line">Object2.Say(); <span class="comment">// ShiJianwen</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Object1.numbers); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="built_in">console</span>.log(Object2.numbers); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h3><p>&emsp;&emsp;原型式继承跟原型链继承有很大不同，它的本质是借助原型基于已有的对象创建新对象，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//用原型实现在原有对象 o 的基础上继承</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种继承方式要求你必须要有一个现成的基础对象供你继承，当你只是需要定义一个与另一个对象相似的对象并且不想大动干戈去创建构造函数的时候，这种方法是可行的，为了规范化这种继承方式，ECMAScript5 为此新增了 Object.create() 方法，但有一点需要注意的是：原型式继承跟原型链一样，对于引用类型值是共享一套数据的，所以具体相关请自主取舍。</p>
<h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h3><p>&emsp;&emsp;寄生式继承跟原型式继承非常相似，它们都是由 JavaScript 大神 DK 推广的，所以它们的思路类似，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span> (<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(origin);</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hi'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用寄生式继承</span></span><br><span class="line"><span class="comment">//定义原始对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"ShiJianwen"</span>,</span><br><span class="line">    numbers: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onePerson = createObject(person);</span><br><span class="line">onePerson.sayHi();</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在这个例子中，object 函数不是必需的，任何能够返回新对象的函数都能取代它，同样注意：使用寄生式继承跟构造函数模式一样，不能做到函数代码复用。</p>
<h3 id="6-寄生组合继承"><a href="#6-寄生组合继承" class="headerlink" title="6.寄生组合继承"></a>6.寄生组合继承</h3><p>&emsp;&emsp;寄生组合继承是为了弥补组合继承中的不足而来的，虽然组合继承是最常用的继承方式，但它还是存在一个问题，就是在使用它的时候会先后调用两次父类型构造函数，这样就会导致实例和原型中拥有两套相同属性，举个例子，在组合继承中代码实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.Say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用构造函数方法继承父类</span></span><br><span class="line">    Father.call(<span class="keyword">this</span>, name);  <span class="comment">//第二次调用 Father()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用原型链继承方法</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">//第一次调用 Father()</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的代码中，我们在定义子类型的时候调用过一次父类型构造函数，在定义子类型的原型的时候又调用了一次，这样一来，子类型的实例和原型中将会拥有两套完全相同的来自父类型的属性，这样会造成不必要的性能以及内存浪费。寄生组合式继承就是为了解决这个问题而生的，所谓寄生组合式继承，就是利用寄生式继承来继承父类型的原型，然后再把结果赋给子类型的原型，基本模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">son, father</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(father.prototype); <span class="comment">//取出一份父类型原型的副本</span></span><br><span class="line">    prototype.constructor = son; <span class="comment">//让实例跟原型重新联系起来</span></span><br><span class="line">    son.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上例中的 inheritPrototype() 函数实现了一个简单的寄生组合式继承，这个函数接受两个参数分别是子类型和父类型的构造函数，第一步是创建父类型的一个副本，第二部是添加 constructor 属性让实例跟原型重新联系起来（因为原型经过重写），最后一步是将新创建的对象赋值给子类型的原型，这样我们就能用这个函数替换掉上面组合继承中的 <code>Son.prototype = new Father();</code> 这一句了，在使用寄生组合式继承的时候我们只调用了一次父类型构造函数，因此避免了重复定义属性，同时原型链也没有遭到破坏，因此普遍认为寄生组合式继承是引用类型最理想的继承方式。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之浅析几种创建对象的方法]]></title>
      <url>http://shijianwen.github.io/2015/04/11/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B5%85%E6%9E%90%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;在 JavaScript 中，创建对象有几种方法，我们平时最常用的是用 Object 构造函数和对象字面量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object 构造函数方法</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Sibarone"</span>;</span><br><span class="line">person.age = <span class="string">"19"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象字面量方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Sibarone"</span>,</span><br><span class="line">    age: <span class="number">19</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>&emsp;&emsp;这两种方法都能创建单个对象，但当用它们来创建多个类似对象时会产生很多重复的代码,因为每生成一个新对象都需要像上面那样重新定义一次，为了解决这类问题，人们开始使用各种模式方法去创建对象，常见的有：</p>
<p><strong><em>工厂模式</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = createPerson (<span class="string">"ShiJianwen"</span>, <span class="number">19</span>, <span class="string">"Frontend Engineer"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;工厂模式是用函数封装创建对象的接口，从而提高代码的复用性，在创建多个相似对象时无需重复定义，但工厂模式的缺点就是无法确定对象类型，即无法得知所创建对象是谁的实例，当你获取该对象的 constructor 属性时无法确定其对象类型，为此人们又提出了新的模式即构造函数模式。</p>
<p><strong><em>构造函数模式</em></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"ShiJianwen"</span>, <span class="number">19</span>, <span class="string">"Frontend Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Sibarone"</span>, <span class="number">19</span>, <span class="string">"Frontend Engineer"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在使用构造函数模式时，可以解决工厂模式无法确定对象类型的问题，此时创建的函数的 constructor 属性即为构造函数 Person，并且当运行 <code>instanceof</code> 方法检测对象类型时也能确定对象类型如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然而构造函数也并非完美，它会重复定义对象内的函数，就像上面代码的 <code>alertName</code> 函数一样，任何一个新建对象的内部都会新建一个 <code>alertName</code> 函数，在 JavaScript 里函数会被当做对象处理，所以每新建一个对象都会实例化一个新的 <code>alertName</code> 对象，以下代码可证明这点<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.alertName == person2.alertName); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;重复地实例化对象会增加性能开销，为了解决这个问题，就出现了原型模式</p>
<p><strong><em>原型模式</em></strong><br>&emsp;&emsp;在 JavaScript 里，创建的每一个函数都有一个 prototype 属性，该属性指向一个对象，其中包含所有实例共享的属性和方法，它同时也是所有通过这个构造函数创建的实例的原型对象（关于原型的知识将会在另一篇博文中详细提到）。使用原型模式创建的对象可以将对象实例的信息直接添加到原型对象中，然后让所有实例共享这些信息。像这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//构造函数为空函数</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"ShiJianwen"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">19</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Frontend Engineer"</span>;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person() <span class="comment">//实例化对象</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在定义原型对象时，我们也可以用对象字面量的形式重写原型对象，像这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"ShiJianwen"</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    job: <span class="string">"Frontend Engineer"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的代码中，我们通过重写字面量来定义原型对象，这样虽然能达到定义原型对象的目的，但是却会有一个严重的问题，就是此时定义的原型对象跟构造函数没有任何关系了。因为每一个原型对象在初始化都会拥有一个 <code>constructor</code> 属性，该属性指向这个原型对象对应的构造函数，像上面的 Person.prototype 对象它本来默认的 <code>constructor</code> 属性就是指向 Person 构造函数的，但是当我们用重写字面量的方式定义原型对象的时候会把 <code>constructor</code> 属性擦除，那么此时定义的原型对象跟构造函数唯一的联系就消失了，为了解决这个问题，我们需要在定义原型对象的时候手动加入 <code>constructor</code> 属性，像这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "ShiJianwen",</span><br><span class="line">    age: 19,</span><br><span class="line">    job: "Frontend Engineer"</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样定义的原型对象就能跟构造函数保持原来的关系了。说完这个我们再转过原型模式创建对象这个问题上来，那么用原型模式来创建对象是不是就是最好的方法呢？当然不是，刚才说到了原型对象里面的所有变量和方法都会被构造函数的所有对象实例共享，如果原型对象只包含基本类型的变量还好，因为在对象实例中重写的基本类型变量会覆盖掉原型里面对应的变量，但是引用类型的变量不一样，如果原型对象里面定义了引用类型的变量，那么对象中所有引用类型的变量都是所有实例共用一份数据的，一旦在哪个实例中改变，那么就会在其他所有实例中体现出来。举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "ShiJianwen",</span><br><span class="line">    age: 19,</span><br><span class="line">    job: "Frontend Engineer",</span><br><span class="line">    arr: [1,2,3,4,5]</span><br><span class="line">&#125;</span><br><span class="line">//定义两个对象实例</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.arr); //输出[1,2,3,4,5]</span><br><span class="line">console.log(person2.arr); //输出[1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">person1.name = "Sibarone"; //改变其中一个实例的基本类型值</span><br><span class="line">person1.arr[0] = 5;        //改变其中一个实例的引用类型值</span><br><span class="line"></span><br><span class="line">console.log(person1.name); //输出Sibarone，原型中的变量被覆盖</span><br><span class="line">console.log(person2.name); //输出ShiJianwen，依然是原型里的变量</span><br><span class="line">console.log(person1.arr); //输出[5,2,3,4,5]</span><br><span class="line">console.log(person2.arr); //输出[5,2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在上面的例子中，由于原型中存在引用类型的变量（arr），所以实际上存储在原型对象中的是该引用类型变量的地址，于是在所有实例对象中该地址都指向同一个数组，只要其中一个实例改变了该数组的元素，那么其他实例也会跟着改变，这就是使用原型模式不好的地方。<br>&emsp;&emsp;所以，为了弥补这些模式诸多的缺点，我们可以使用多种模式组合创建对象的方式，比如构造函数模式跟原型模式的组合使用就是如今创建对象最常见的方式，其中用构造函数模式来定义属性，用原型模式来定义实例间共享的方法和属性，这样既避免了重复定义对象的内存浪费，又避免了因为共享造成的使用不方便的问题。我们可以用这种模式来重新定义前面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    alertName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.arr);<span class="comment">//输出 [5,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.arr);<span class="comment">//输出[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样就不存在前面说的那些问题啦。当然如果你觉得这样把两种模式独立起来创建对象不好的话也可以使用<strong><em>动态原型模式</em></strong>，它就是在同一个构造函数中初始化对象，同时保持使用原型模式和构造函数模式的优点。再来个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.alertName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这样就是能在同一个构造函数中初始化对象而不用把两种模式独立起来使用。除此之外，在上面几种模式都不适用的情况下，我们可以试试使用<strong><em>寄生构造函数模式</em></strong>，栗子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;；</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种模式看起来像是工厂模式和构造函数模式的结合，它的基本思想就是创建一个函数，用来封装创建对象的代码。这个模式可以在特殊情况下为对象创建构造函数，比如我们想要数组拥有一个特殊的方法，但是我们却不能去修改 Array 构造函数，这是就可以使用这种模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">specialArr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    values.push.apply(values,<span class="built_in">arguments</span>);</span><br><span class="line">    values.pipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> specialArr(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.pipedString()); <span class="comment">//输出[1|2|3]</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的例子定义一个可以创建特殊数组的构造函数，我们在里面定义了 <code>pipedString</code> 方法，它可以生成一个用 “|” 分割的数组，一般来说在 Array 构造函数里面是不允许修改 Array 构造函数，所以就无法借助 Array 构造函数来生成这个特殊数组，但是使用寄生构造函数模式就能达到这个目的，这也就是它为什么叫寄生构造函数模式的原因，因为它能够在不影响其他构造函数的情况下去拓展这个构造函数。但是使用它有一个需要注意的地方就是它跟工厂模式一样无法确定对象类型，用它创建的对象实例跟这个构造函数之间没有任何关系，所以在能用其他模式创建对象的情况下，一般不建议用这种模式创建。<br>&emsp;&emsp;在寄生构造函数模式之后，有人提出了<strong><em>稳妥对象</em></strong>的概念，稳妥对象指的是没有公共属性，且其中方法不访问 this 关键字的对象，这种对象能够保证数据的安全并且防止数据被其他应用程序使用，这种模式也适合在一些安全要求比较高的环境中使用，具体实例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = Person(<span class="string">"ShiJianwen"</span>, <span class="number">19</span>, <span class="string">"Frontend Engineer"</span>);</span><br><span class="line">person.alertName();<span class="comment">//输出ShiJianwen</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从上面的代码看起来，稳妥构造函数模式跟寄生构造函数模式很像，但不同的是，稳妥构造函数模式没有引用 this，同时在实例化时也没有使用 new 操作符。这种模式下创建的对象中除了那个 alertName 函数，谁也无法访问 name 属性，这种安全性就是该模式最大的特点。但同样要注意的是，稳妥构造函数模式跟寄生构造函数模式一样，创建的对象都无法确定其对象类型。<br>&emsp;&emsp;好了，总的这几种创建对象方法都讲得差不多了，其中关于原型的知识可能没有说得太明白有些人依旧会有些迷惑，所以有关原型跟原型链的知识我都会写在另一篇博文中，敬请期待。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之深入理解执行环境与作用域链]]></title>
      <url>http://shijianwen.github.io/2015/04/06/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      <content type="html"><![CDATA[<h2 id="执行环境和作用域链"><a href="#执行环境和作用域链" class="headerlink" title="执行环境和作用域链"></a>执行环境和作用域链</h2><p>&emsp;&emsp;执行环境和作用域链是 JavaScript 里最重要的一个概念，在讲它们之前，先简单解释一下两个名词：‘变量对象’和‘活动对象’。</p>
<p>&emsp;&emsp;<strong>变量对象</strong><br>&emsp;&emsp;变量对象是当代码执行流进入作用域时创建的一个包含该作用域内所有变量和函数声明的对象（<strong>注意：函数表达式不在此列</strong>）。<br>&emsp;&emsp;<strong>活动对象</strong><br>&emsp;&emsp;活动对象是函数执行时创建的一个对象，这个对象包含函数的形参以及所有局部变量，它跟上面的变量对象正好是相对关系。<br><a id="more"></a></p>
<p>&emsp;&emsp;在 JavaScript 里，执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为（<strong><em>比如在一个函数内部是无法访问该函数的子函数的内部变量的，因为在这个父函数的执行环境里没有定义子函数中的任何数据</em></strong>）。每个执行环境都有自己对应的一个变量对象，全局环境是处于最外围的一个执行环境（<strong><em>一般认为就是 Window 对象</em></strong>），当一个执行环境的所有代码执行完之后，该执行环境和它里面的变量都会被销毁（<strong><em>全局环境在应用程序退出时才会被销毁</em></strong>）。每个 JavaScript 函数也都有自己的执行环境，当代码执行流进入一个函数时，函数的执行环境会被压入环境栈里，直到函数执行完毕才会将其弹出，并把控制权交给之前的执行环境。<br>&emsp;&emsp;当代码执行流进入一个环境时，会创建一个该环境变量对象的作用域链（<strong><em>如果遇到函数则用函数环境中的活动对象当做变量对象</em></strong>），用来保证访问变量和函数的顺序（<strong><em>就像变量查找一样，首先会在当前作用域查找，如果没有，再去父作用域找</em></strong>）。当前执行环境的变量对象始终位于作用域链的最前端，往后一个变量对象是当前执行环境的外部环境，再后一个变量对象则是更外面的环境，这样一直延续到全局执行环境，就形成了一条完整的作用域链，要注意全局环境的变量对象始终都是作用域链中的最后一个对象。<br>&emsp;&emsp;变量查找的过程就是沿着作用域链从最前端开始一级一级往后查找的过程，一直到全局作用域为止，如果全局环境中依然没有定义这个变量，那么就会返回 Undefined 或者严格模式下报错。同时由于执行环境的存在，使得父作用域无法访问子作用域，而子作用域却能够访问父作用域中的任何变量和函数。</p>
<p>&emsp;&emsp;试分析以下代码</p>
<pre><code>var name = &quot;Sibarone&quot;;
function Func1 () {
    var age = 20;
    function Func2 () {
        var tempName = name;
        console.log(&quot;My name is &quot; + tempName + &quot;,&quot; + age);
    }
    Func2();
}
Func1();
</code></pre><p>&emsp;&emsp;上面的代码一共包含了三个执行环境，分别是 Func2、Func1 和全局执行环境，全局环境里的变量对象包含了变量 <code>name</code> 和函数 <code>Func1</code>；Func1的执行环境里定义了变量 <code>age</code> 和函数 <code>Func2</code>，同时该环境可以访问全局环境里的所有变量；Func2的执行环境里定义了变量 <code>tempName</code>，这个变量只能在该环境被访问，无法被外部环境访问，但是这个环境可以访问它的所有外部环境的变量，外部的任何变量对它都是公开的。</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>&emsp;&emsp;JavaScript 的作用域链除了局部环境和全局环境的组合之外，还可以人为延长作用域链，具体来说，就是当代码执行流进入 <code>with</code> 或者 <code>try...catch</code> 语句时，作用域链都会得到延长：</p>
<p>&emsp;&emsp;<strong><em>with语句</em></strong><br>&emsp;&emsp;在 JavaScript 中，with 语句用于设置代码当前对象的执行环境，用代码表示如下：</p>
<pre><code>var name = &quot;Sibarone&quot;; //全局定义一个变量
var someObject = {
    name: &quot;ShiJianwen&quot; //定义一个内部变量
}
with (someObject) {
    console.log(name); //输出”ShiJianwen“；
}
console.log(name);    //输出”Sibarone“
</code></pre><p>&emsp;&emsp;上面的代码中有两个输出语句，正常情况下都是应该输出 Sibarone 的，因为它是一个全局变量，但是使用了 with 语句后当前代码的执行环境被强行变成了 someObject，所以此时在 with 语句里输出的名字就应该是 someObject 中定义的 name 变量。到这里我想大家都明白 with 延长作用域链的原理了吧？其实就是 with 语句在更改执行环境的时候会把这个执行环境的变量对象推入到作用域链的最前端，上面代码就是把 someObject 的环境的变量对象推到整个作用域链的最前端，使得变量查找的时候在作用域链的最前端就能找到 name 变量，这样就不会访问到全局的 name 变量了。</p>
<p>&emsp;&emsp;<strong><em>try…catch语句</em></strong><br>&emsp;&emsp;try 和 catch 语句在 JavaScript 中总是成对出现的，它们的作用主要是检查代码的语法错误，拼写错误和各种不可预知因素导致的错误。try 语句用来测试代码的错误，catch 语句用来处理错误，经常跟 try…catch 一起使用的还有 throw 语句，throw 语句主要用来抛出错误，完成自定义的错误提示。更多关于 try…catch 语句的知识可以看[这里][1]。在运行 try…catch 语句的时候，catch 语句块的执行环境会生成一个新的变量对象加入到作用域链的前端从而达到延长作用域链的目的。用代码表示如下：</p>
<pre><code>try {
    allert(&quot;abc&quot;);  //写一段出错的代码
}
catch (err) {   //错误被捕捉到后会执行这里的 catch 语句
    console.log(err.message);   //访问错误对象，输出错误信息
}
console.log(err.message); //报错 not defined，无法访问
</code></pre><p>&emsp;&emsp;如果你对我刚刚说的变量查找规则还有点印象的话那相信你也看懂了在这里 catch 语句确实延长了作用域链，在变量查找的过程中，总是会先从作用域链的最前端开始查起，一直追溯到全局环境的变量对象，在上面的代码中，假设如果 catch 语句没有延长作用域链，那么我在最后一行（catch 语句外部）输出错误信息时应该是不会报错的（<strong><em>因为 JavaScript 没有块级作用域这一说法，<code>注1</code> 解释这点</em></strong>），因为大家都处于同一个作用域中，变量查找是能找到本作用域的所有变量的，但事实却是代码报错，想想变量查找的时候为什么会报错？原因就是真正 err 对象根本不在本作用域里！也不在父作用域里，它被定义在当前输出环境的子作用域里，也就是作用域链的最前端！它里面的错误对象组成了一个新的变量对象然后被加到作用域的最前端。这就证明了代码的作用域的确是被延长了。</p>
<p>&emsp;&emsp;注1：在类 C 语言中，由花括号封闭的代码会形成自己的块级作用域（JavaScript 叫它执行环境），在花括号外部是无法访问花括号内部的任何变量的，但是在 JavaScript 中没有块级作用域这一说法，在花括号外部依然能够访问花括号内部的变量，当然函数的花括号除外，因为函数有自己的执行环境。同样要注意的是在讲 catch 语句能够延长作用域链时只是针对 catch 语句捕获的错误对象 err 来说的，如果在 catch 语句块里面定义一个变量，在 catch 外还是能够访问的，原因同上（块级作用域问题）。<br>&emsp;&emsp;注2：在 IE8 及其之前版本中，catch 语句执行后捕获到的错误对象不会被新增进一个变量对象然后加入作用域链前端，而是直接被加到当前执行环境的变量对象中去，所以在 catch 语句外部也能访问错误对象 err，但在 IE9 中修复了这个 Bug。<br>  [1]: <a href="http://www.w3school.com.cn/js/js_errors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/js/js_errors.asp</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记之数组的深拷贝]]></title>
      <url>http://shijianwen.github.io/2015/04/02/JS%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;由于JavaScript的数据分为‘原始类型’和‘引用类型’，数组Array是引用类型，与c语言类似，对数组直接用‘=’号赋值的话，赋给变量的值只是该数组的引用地址（c语言中叫指针），并没有实现数组数据的拷贝，两个数组共享同一组数据，也就是说一旦修改这两个数组中的任何一方，该修改也会在另一方体现出来。具体代码如下：<br><a id="more"></a><br>错误示例1：</p>
<pre><code>var arr1 = [1,2,3,4,5],arr2;
arr2 = arr1;        //简单赋值
console.log(arr2);  //输出[1,2,3,4,5],说明赋值成功
arr1.length = 0;    //清空数组1
console.log(arr2)   //此处输出[]；空数组，说明两个数组共享数据
</code></pre><p>&emsp;&emsp;要想实现数组的深拷贝，除了for循环遍历赋值外，一维数组还可以使用‘slice’或者’concat’方法：</p>
<p>一维数组深拷贝：</p>
<pre><code>var arr1 = [1,2,3,4,5],arr2,arr3;
arr2 = arr1.slice(0);   //使用slice方法
arr3 = arr1.concat();   //使用concat方法
arr1.length = 0;        //清空数组1
console.log(&apos;arr2: &apos; + arr2);   //输出arr2: [1,2,3,4,5]
console.log(&apos;arr3: &apos; + arr3);   //输出arr3: [1,2,3,4,5]
</code></pre><p>&emsp;&emsp;关于slice和concat两个方法更详细的内容可以看这里 <a href="http://www.w3school.com.cn/jsref/jsref_slice_string.asp" target="_blank" rel="noopener">slice方法</a>  <a href="http://www.w3school.com.cn/jsref/jsref_concat_array.asp" target="_blank" rel="noopener">concat方法</a></p>
<p>&emsp;&emsp;对于一维数组来说slice和concat方法能够实现数组的深拷贝，但如果原数组是多维的比如是<code>[1,2,3,[4,5]]</code>这样的数组，由于对于二维数组或者多维数组来说，它的第一维元素里面存储的是第二维元素的地址，所以在高维层面的数据依旧是共享的，具体代码如下：</p>
<p>错误示例2：</p>
<pre><code>var arr1 = [1,2,3,[4,5]],arr2,arr3;
arr2 = arr1.slice(0);
arr3 = arr1.concat();
console.log(arr2[3][1]);    //输出5
arr1[3][1] = 0;             //改变原数组中的高维元素
console.log(arr2[3][1]);    //输出0
console.log(arr3[3][1]);    //输出0
</code></pre><p>&emsp;&emsp;要想实现高维数组的深拷贝，可用JS函数来实现：</p>
<p>多维数组的深拷贝：</p>
<pre><code>function deepCopy(arr) {
        var result = [];
        for (var i = 0; i &lt; arr.length; i++) {  //遍历原数组
            if (arr[i] instanceof Array){
                result[i] = deepCopy(arr[i]);   //若数组多维，则递归调用函数
            }
            else result[i] = arr[i];
        }
        return result;
    }
    //现在我们来试试多维数组的深拷贝
    var arr1 = [1,2,3,[4,5,6]],arr2;
    arr2 = deepCopy(arr1);
    arr1[3][0] = 0;     //修改高维元素
    console.log(arr2[3][0]);    //输出4，没有改变
</code></pre><p>上述函数在JQuery可表示如下：</p>
<pre><code>arr2 = $.extend(true, {}, arr1);
</code></pre>]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Win7 64位硬盘安装Ubuntu14.10 64位无法进入安装界面解决方法]]></title>
      <url>http://shijianwen.github.io/2015/01/25/ubuntu-question/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;最近给系统升级，诸多问题陆续出现，首先Ubuntu14.10桌面版无法使用U盘启动，这里与问题无关暂且不表，但是也建议大家少用U盘安装。<br><a id="more"></a><br>&emsp;&emsp;由于不能U盘安装于是我使用了easyBCD引导本地硬盘安装的方法来安装Ubuntu，由于安装的是64的系统，按照常规的方式硬盘启动的话会出现无法进入Ubuntu安装界面的问题，查阅资料后我发现是一个小地方出错了：<br>当我们安装并且配置好easyBCD新建的NeoGrub之后，下一步就是把镜像文件移动到C盘根目录下，然后解压出镜像文件中的 initrd.lz 和 vmlinuz.efi 文件，如果只是安装32位Ubuntu的话到这一步完成就能够重启了，但是64位系统是只识别vmlinuz的，所以下一步我们还需要将 vmlinuz.efi 的后缀 .efi 去掉，然后再启动，就能顺利进入安装界面了！</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
